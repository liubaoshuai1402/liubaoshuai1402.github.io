<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DFT on BOGHTW</title>
    <link>https://liubaoshuai1402.github.io/categories/dft/</link>
    <description>Recent content in DFT on BOGHTW</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 16 Jul 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://liubaoshuai1402.github.io/categories/dft/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>超晶格材料原子尺度建模</title>
      <link>https://liubaoshuai1402.github.io/dft/themodelingofsuperlattice/</link>
      <pubDate>Wed, 16 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/dft/themodelingofsuperlattice/</guid>
      <description>&lt;h1 id=&#34;超晶格材料原子尺度建模&#34;&gt;超晶格材料原子尺度建模&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;虽然异质结的建模攻略很多，但大都以Material Studio为主，且对象是表界面。对于周期性的超晶格材料的建模，特别是异质结情况，参考较少，这里我分享一下个人的经验。采用ASE进行建模。&lt;/p&gt;&#xA;&lt;p&gt;异质结的两种材料接触时，哪两个面间的接触，是需要确定的，比如说，根据实验确定，又或者无实验时，根据晶格匹配度确定，尽量保证失配度较低。&lt;/p&gt;&#xA;&lt;p&gt;这里，假设已经确定了，两个材料的晶胞要沿着z轴堆叠。&lt;/p&gt;&#xA;&lt;p&gt;整体思路：&lt;/p&gt;&#xA;&lt;p&gt;1.确定好要合并的两个晶格的具体结构（用translate平移，surface切面，这个顺序好像也能反过来）&lt;/p&gt;&#xA;&lt;p&gt;2.合并晶格（stack用起来还是蛮需要经验的）&lt;/p&gt;&#xA;&lt;h3 id=&#34;如何切一个晶面并生成周期性结构&#34;&gt;如何切一个晶面，并生成周期性结构&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ase.build import surface,stack,make_supercell&#xD;&#xA;from ase.io import read,write&#xD;&#xA;from ase.io.vasp import write_vasp&#xD;&#xA;&#xD;&#xA;BiTe = read(&#39;POSCAR_BiTe&#39;)&#xD;&#xA;BiTe = make_supercell(BiTe,P=[[2,0,0],[0,1,0],[0,0,1]])&#xD;&#xA;BiTe1 = BiTe.copy()&#xD;&#xA;BiTe2 = BiTe.copy()&#xD;&#xA;BiTe2.translate([0,0,-2.05985])&#xD;&#xA;BiTe3 = BiTe.copy()&#xD;&#xA;BiTe3.translate([0,0,-3.79553])&#xD;&#xA;&#xD;&#xA;BiTe1 = surface(BiTe1,indices=(0,0,1),layers=1,periodic=True)&#xD;&#xA;BiTe2 = surface(BiTe2,indices=(0,0,1),layers=1,periodic=True)&#xD;&#xA;BiTe3 = surface(BiTe3,indices=(0,0,1),layers=1,periodic=True)&#xD;&#xA;write_vasp(&#39;POSCAR_BiTe1&#39;,BiTe1,direct=True,sort=True)&#xD;&#xA;write_vasp(&#39;POSCAR_BiTe2&#39;,BiTe2,direct=True,sort=True)&#xD;&#xA;write_vasp(&#39;POSCAR_BiTe3&#39;,BiTe3,direct=True,sort=True)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;ase的surface函数可以很简单的实现，这里不赘述了。&lt;/p&gt;&#xA;&lt;p&gt;此外，关于如何确定一个合适的新晶格的大小，也有很多视频讲解，不再赘述。&lt;/p&gt;&#xA;&lt;h3 id=&#34;改变晶体结构的原子层顺序&#34;&gt;改变晶体结构的原子层顺序&lt;/h3&gt;&#xA;&lt;p&gt;即便是只有一种原子的晶体，其沿某个面的堆垛的时候，可能有不同的层。比如FCC晶体沿001面的堆垛方式就是&amp;mdash;ABAB&amp;mdash;，显然与别的物质形成异质结时，会面临一个问题，即是A面还是B面与别的物质接触。&lt;/p&gt;&#xA;&lt;p&gt;我们建模时，需要把A面或B面调整出来。这需要对原子进行整体位移&lt;/p&gt;&#xA;&lt;p&gt;此外，异质结平面内的原子对齐（比如说xy面），也需要对原子进行整体位移。&lt;/p&gt;&#xA;&lt;p&gt;而ASE实现原子整体位移非常简单，只需要用&lt;code&gt;atoms&lt;/code&gt;类的&lt;code&gt;translate&lt;/code&gt;方法即可，注意使用绝对坐标。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ase.build import surface,stack,make_supercell&#xD;&#xA;from ase.io import read,write&#xD;&#xA;from ase.io.vasp import write_vasp&#xD;&#xA;&#xD;&#xA;BiTe = read(&#39;POSCAR_BiTe&#39;)&#xD;&#xA;BiTe = make_supercell(BiTe,P=[[2,0,0],[0,1,0],[0,0,1]])&#xD;&#xA;BiTe1 = BiTe.copy()&#xD;&#xA;BiTe2 = BiTe.copy()&#xD;&#xA;BiTe2.translate([0,0,-2.05985])&#xD;&#xA;BiTe3 = BiTe.copy()&#xD;&#xA;BiTe3.translate([0,0,-3.79553])&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;ase实现超晶格材料建模&#34;&gt;ASE实现超晶格材料建模&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ase.build import surface,stack,make_supercell&#xD;&#xA;from ase.io import read,write&#xD;&#xA;from ase.io.vasp import write_vasp&#xD;&#xA;&#xD;&#xA;BiTe1 = read(&#39;POSCAR_BiTe1&#39;)&#xD;&#xA;BiTe2 = read(&#39;POSCAR_BiTe2&#39;)&#xD;&#xA;BiTe3 = read(&#39;POSCAR_BiTe3&#39;)&#xD;&#xA;&#xD;&#xA;Ag = make_supercell(read(&#39;POSCAR_Ag&#39;),P=[[2,0,0],[0,2,0],[0,0,3]])&#xD;&#xA;BiTe1_Ag = stack(Ag,BiTe1,axis=2,fix=0.5)&#xD;&#xA;BiTe2_Ag = stack(Ag,BiTe2,axis=2,fix=0.5)&#xD;&#xA;BiTe3_Ag = stack(Ag,BiTe3,axis=2,fix=0.5)&#xD;&#xA;&#xD;&#xA;write(&#39;POSCAR_BiTe1_Ag&#39;,BiTe1_Ag,format=&#39;vasp&#39;)&#xD;&#xA;write(&#39;POSCAR_BiTe2_Ag&#39;,BiTe2_Ag,format=&#39;vasp&#39;)&#xD;&#xA;write(&#39;POSCAR_BiTe3_Ag&#39;,BiTe3_Ag,format=&#39;vasp&#39;)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/spl1.png&#34;/&gt;&#xD;&#xA;&lt;h5 id=&#34;关于ase中stack函数的原理&#34;&gt;关于ase中stack函数的原理。&lt;/h5&gt;&#xA;&lt;p&gt;将两个周期性的晶胞合并成一个周期性的晶胞，有一个必须要面对的问题，那就是接触面将不再有周期性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>随机取代晶体结构中的元素</title>
      <link>https://liubaoshuai1402.github.io/dft/%E9%9A%8F%E6%9C%BA%E5%8F%96%E4%BB%A3%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 16 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/dft/%E9%9A%8F%E6%9C%BA%E5%8F%96%E4%BB%A3%E5%85%83%E7%B4%A0/</guid>
      <description>&lt;h1 id=&#34;从一个实例中学习python中的排列组合的实现&#34;&gt;从一个实例中学习python中的排列组合的实现&lt;/h1&gt;&#xA;&lt;h2 id=&#34;zro2中掺杂y元素&#34;&gt;ZrO2中掺杂Y元素&lt;/h2&gt;&#xA;&lt;p&gt;一个96原子的晶胞，去掉一个氧空位，再取代两个Zr原子，就是一个通用的YSZ模型（95 原子）。&lt;/p&gt;&#xA;&lt;p&gt;但是Y与Vo的相对位置，是一个麻烦。&lt;/p&gt;&#xA;&lt;p&gt;Y的掺杂会不会带来晶胞大小的变化。我这里的处理是根据以往的文献，确定一个可能的构型。&lt;/p&gt;&#xA;&lt;p&gt;然后考虑一下掺杂对晶胞尺寸带来的影响，然后就定了，Y再换其他位置也认为不会再影响了。（因为比起相对位置，肯定有无Y原子才是影响的大头）&lt;/p&gt;&#xA;&lt;p&gt;确定了晶胞尺寸，结构优化后，再把Y换成Zr。然后随机取代，最终确定$C_{32}^2$个结构，计算单点能，用于机器学习势学习。&lt;/p&gt;&#xA;&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;&#xA;&lt;p&gt;由大G老师支持。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ase.io import read&#xD;&#xA;from ase.io.vasp import write_vasp&#xD;&#xA;from itertools import combinations&#xD;&#xA;import os&#xD;&#xA;&#xD;&#xA;at = read(&#39;POSCAR&#39;)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 找到所有 Zr 原子的索引&#xD;&#xA;zr_indices = [i for i, atom in enumerate(at) if atom.symbol == &#39;Zr&#39;]&#xD;&#xA;print(f&amp;quot;找到 {len(zr_indices)} 个 Zr 原子&amp;quot;)&#xD;&#xA;&#xD;&#xA;# 创建保存目录&#xD;&#xA;os.makedirs(&amp;quot;ZrO_Y2_structures&amp;quot;, exist_ok=True)&#xD;&#xA;&#xD;&#xA;# 枚举所有 Zr 的两两组合，逐个替换为 Y&#xD;&#xA;for count, (i, j) in enumerate(combinations(zr_indices, 2)):&#xD;&#xA;    new_at = at.copy()&#xD;&#xA;    new_at[i].symbol = &#39;Y&#39;&#xD;&#xA;    new_at[j].symbol = &#39;Y&#39;&#xD;&#xA;&#xD;&#xA;    # 写入文件    &#xD;&#xA;    subdir = f&amp;quot;ZrO_Y2_structures/{count}&amp;quot;&#xD;&#xA;    os.makedirs(subdir, exist_ok=True)&#xD;&#xA;    filename = os.path.join(subdir, &amp;quot;POSCAR&amp;quot;)&#xD;&#xA;    write_vasp(filename, new_at,direct=True,sort=True)&#xD;&#xA;    print(f&amp;quot;写入结构：{filename}&amp;quot;)&#xD;&#xA;&#xD;&#xA;print(f&amp;quot;共生成 {count + 1} 个结构。&amp;quot;)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;combations&lt;/code&gt;类是python中实现组合的高效方式。参数为一个列表，一个长度。返回一个包含若干元组的列表。&lt;/p&gt;</description>
    </item>
    <item>
      <title>COHP</title>
      <link>https://liubaoshuai1402.github.io/dft/cohp/</link>
      <pubDate>Sat, 28 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/dft/cohp/</guid>
      <description>&lt;h1 id=&#34;cohp&#34;&gt;COHP&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;h3 id=&#34;vasp文件的准备&#34;&gt;VASP文件的准备&lt;/h3&gt;&#xA;&lt;p&gt;LOBSTER要求ISYM=0或-1。其他参数没有特殊要求。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;结构优化&lt;/p&gt;&#xA;&lt;p&gt;略过&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;静态自洽&lt;/p&gt;&#xA;&lt;p&gt;以较为简单的K点设置计算波函数、电荷密度。&lt;/p&gt;&#xA;&lt;p&gt;用于得到WAVECAR、CHGCAR&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;#关键参数&#xD;&#xA;ISTART  = 0            &#xD;&#xA;ICHARG  = 2&#xD;&#xA;NSW = 0&#xD;&#xA;NBANDS = 500&#x9;#这个值要大，多试试&#xD;&#xA;NEDOS = 1000&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;后续的非静态自洽的NBANDS和NEDOS尽量和这里保持一致。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;非静态自洽&lt;/p&gt;&#xA;&lt;p&gt;不再更新波函数和电荷密度，进行一次单次的求解。&lt;/p&gt;&#xA;&lt;p&gt;这里可以设置更密的K点来求态密度，也可以设置特殊路径的K点来求能带结构。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;#关键参数&#xD;&#xA;ISTART = 1     # 使用前一轮的波函数&#xD;&#xA;ICHARG = 11    # 使用前一轮的电荷密度，不再更新&#xD;&#xA;NSW = 0&#xD;&#xA;LORBIT = 12&#xD;&#xA;NBANDS = 500&#x9;#这个值要大，多试试&#xD;&#xA;NEDOS = 1000&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;特别说一下LORBIT参数，这个参数是后处理参数，和VASP的电子计算无关。&lt;/p&gt;&#xA;&lt;p&gt;指示VASP生成：DOSCAR and lm-decomposed PROCAR + phase factors (not recommended)&lt;/p&gt;&#xA;&lt;p&gt;所以只需要最后非静态自洽的时候设置即可。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;另外，如果对精度不高，或者不考虑成本，我看也有人直接用静态自洽的结果（这里直接设置比较高的K点密度）进行LOBSTER。&lt;/p&gt;&#xA;&lt;p&gt;如果用的&lt;code&gt;ISMEAR = 0&lt;/code&gt;，后续要在lobsterin文件中指出。&lt;/p&gt;</description>
    </item>
    <item>
      <title>用VASP进行第一性原理分子动力学（AIMD）</title>
      <link>https://liubaoshuai1402.github.io/dft/aimd/</link>
      <pubDate>Sat, 28 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/dft/aimd/</guid>
      <description>&lt;h1 id=&#34;aimd&#34;&gt;AIMD&lt;/h1&gt;&#xA;&lt;h3 id=&#34;nvt系综&#34;&gt;nvt系综&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;ISTART = 0&#xD;&#xA;ENCUT = 480&#xD;&#xA;PREC = Normal&#xD;&#xA;ALGO = Fast&#xD;&#xA;LREAL = Auto&#xD;&#xA;LWAVE = .F. &#xD;&#xA;LCHARG = .F.&#xD;&#xA;GGA = PS&#xD;&#xA;ISMEAR = 0&#xD;&#xA;SIGMA = 0.05&#xD;&#xA;ISPIN = 1&#xD;&#xA;&#xD;&#xA;#electronstep&#xD;&#xA;NELM = 200&#xD;&#xA;NELMIN = 4&#xD;&#xA;EDIFF = 1E-4&#xD;&#xA;&#xD;&#xA;#AIMD&#xD;&#xA;IBRION = 0                  &#xD;&#xA;MDALGO = 2                      &#xD;&#xA;ISIF = 2                         &#xD;&#xA;TEBEG = 1500               &#xD;&#xA;NSW = 5000                     &#xD;&#xA;POTIM = 0.5                    &#xD;&#xA;SMASS = 0.5&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;IBRION&lt;/code&gt;是控制离子步优化算法的参数，进行分子动力学是设置为0。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;MDALGO&lt;/code&gt;这个参数控制恒温器选项。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
