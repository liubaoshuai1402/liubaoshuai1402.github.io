<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DFT on BOGHTW</title><link>https://liubaoshuai1402.github.io/categories/dft/</link><description>Recent content in DFT on BOGHTW</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 15 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://liubaoshuai1402.github.io/categories/dft/index.xml" rel="self" type="application/rss+xml"/><item><title>超晶格材料原子尺度建模</title><link>https://liubaoshuai1402.github.io/dft/%E6%8C%87%E5%AE%9Aposcar%E5%8E%9F%E5%AD%90%E7%9A%84%E8%87%AA%E7%94%B1%E5%BA%A6/</link><pubDate>Fri, 15 Aug 2025 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/%E6%8C%87%E5%AE%9Aposcar%E5%8E%9F%E5%AD%90%E7%9A%84%E8%87%AA%E7%94%B1%E5%BA%A6/</guid><description>&lt;p&gt;根据原子的z轴坐标，指定哪些是自由的，哪些是受限制的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ase.constraints import FixAtoms
from ase.io import write, read

fixed_indices = [] # 要固定的原子索引
atoms = read('POSCAR_BiTe1_Pt')
for i in range(len(atoms)):
 position_z = atoms[i].position[2]
 if 40 &amp;gt; position_z &amp;gt; 15.5:
 indice = atoms[i].index
 fixed_indices.append(indice)
 if 3 &amp;lt; position_z &amp;lt; 7:
 indice = atoms[i].index
 fixed_indices.append(indice)

atoms.set_constraint(FixAtoms(indices=fixed_indices))
write('POSCAR_BiTe1_Pt_sel', atoms, format='vasp')




&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>晶体表面建模</title><link>https://liubaoshuai1402.github.io/dft/themodelingofsurface/</link><pubDate>Thu, 14 Aug 2025 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/themodelingofsurface/</guid><description>&lt;h1 id="晶体表面建模"&gt;晶体表面建模&lt;/h1&gt;
&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;晶体表面建模中有很多细节。&lt;/p&gt;
&lt;p&gt;比如说，要建模(111)面，首先要给出切表面时所采用的晶胞，是primitive cell ？还是conventional cell ？还是自己定义的晶胞。&lt;/p&gt;
&lt;p&gt;以四方氧化锆为例，
&lt;a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.58.8050" target="_blank" rel="noopener noreferrer" &gt;在这篇文献中&lt;/a&gt;
，计算得到的最稳定表面是(111)，作者就明确指出，他切表面时采用的是重构后的类CaF&lt;sub&gt;2&lt;/sub&gt;型的晶胞，而非原胞。&lt;/p&gt;
&lt;p&gt;实际上，对于四方氧化锆，这种晶胞的(111)面与原胞的(101)面是同一个面，这也就是为什么有很多文献说，四方氧化锆的最稳定表面是(101)面。&lt;/p&gt;
&lt;p&gt;虽然不指出具体的切割的晶胞时，人们可能会默认为是用的原胞，但我个人认为还是明确指出为好，防止引起不必要的误解。&lt;/p&gt;
&lt;p&gt;其次，除了密勒指数，UV矢量也很重要，即面内的两个坐标轴，他觉得&lt;/p&gt;</description></item><item><title>超晶格材料原子尺度建模</title><link>https://liubaoshuai1402.github.io/dft/themodelingofsuperlattice/</link><pubDate>Tue, 05 Aug 2025 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/themodelingofsuperlattice/</guid><description>&lt;h1 id="超晶格材料原子尺度建模"&gt;超晶格材料原子尺度建模&lt;/h1&gt;
&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;虽然异质结的建模攻略很多，但大都以Material Studio为主，且对象是表界面。对于周期性的超晶格材料的建模，特别是异质结情况，参考较少，这里我分享一下个人的经验。采用ASE进行建模。&lt;/p&gt;
&lt;p&gt;异质结的两种材料接触时，哪两个面间的接触，是需要确定的，比如说，根据实验确定，又或者无实验时，根据晶格匹配度确定，尽量保证失配度较低。&lt;/p&gt;
&lt;p&gt;这里，假设已经确定了，两个材料的晶胞要沿着z轴堆叠。&lt;/p&gt;
&lt;p&gt;整体思路：&lt;/p&gt;
&lt;p&gt;1.确定好要合并的两个晶格的具体结构（用translate平移，surface切面，这个顺序好像也能反过来）&lt;/p&gt;
&lt;p&gt;2.合并晶格（stack用起来还是蛮需要经验的）&lt;/p&gt;
&lt;h3 id="如何切一个晶面并生成周期性结构"&gt;如何切一个晶面，并生成周期性结构&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ase.build import surface,stack,make_supercell
from ase.io import read,write
from ase.io.vasp import write_vasp

BiTe = read('POSCAR_BiTe')
BiTe = make_supercell(BiTe,P=[[2,0,0],[0,1,0],[0,0,1]])
BiTe1 = BiTe.copy()
BiTe2 = BiTe.copy()
BiTe2.translate([0,0,-2.05985])
BiTe3 = BiTe.copy()
BiTe3.translate([0,0,-3.79553])

BiTe1 = surface(BiTe1,indices=(0,0,1),layers=1,periodic=True)
BiTe2 = surface(BiTe2,indices=(0,0,1),layers=1,periodic=True)
BiTe3 = surface(BiTe3,indices=(0,0,1),layers=1,periodic=True)
write_vasp('POSCAR_BiTe1',BiTe1,direct=True,sort=True)
write_vasp('POSCAR_BiTe2',BiTe2,direct=True,sort=True)
write_vasp('POSCAR_BiTe3',BiTe3,direct=True,sort=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ase的surface函数可以很简单的实现，这里不赘述了。&lt;/p&gt;
&lt;p&gt;此外，关于如何确定一个合适的新晶格的大小，也有很多视频讲解，不再赘述。&lt;/p&gt;
&lt;h3 id="改变晶体结构的原子层顺序"&gt;改变晶体结构的原子层顺序&lt;/h3&gt;
&lt;p&gt;即便是只有一种原子的晶体，其沿某个面的堆垛的时候，可能有不同的层。比如FCC晶体沿001面的堆垛方式就是&amp;mdash;ABAB&amp;mdash;，显然与别的物质形成异质结时，会面临一个问题，即是A面还是B面与别的物质接触。&lt;/p&gt;
&lt;p&gt;我们建模时，需要把A面或B面调整出来。这需要对原子进行整体位移&lt;/p&gt;
&lt;p&gt;此外，异质结平面内的原子对齐（比如说xy面），也需要对原子进行整体位移。&lt;/p&gt;
&lt;p&gt;而ASE实现原子整体位移非常简单，只需要用&lt;code&gt;atoms&lt;/code&gt;类的&lt;code&gt;translate&lt;/code&gt;方法即可，注意使用绝对坐标。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ase.build import surface,stack,make_supercell
from ase.io import read,write
from ase.io.vasp import write_vasp

BiTe = read('POSCAR_BiTe')
BiTe = make_supercell(BiTe,P=[[2,0,0],[0,1,0],[0,0,1]])
BiTe1 = BiTe.copy()
BiTe2 = BiTe.copy()
BiTe2.translate([0,0,-2.05985])
BiTe3 = BiTe.copy()
BiTe3.translate([0,0,-3.79553])
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="ase实现超晶格材料建模"&gt;ASE实现超晶格材料建模&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ase.build import surface,stack,make_supercell
from ase.io import read,write
from ase.io.vasp import write_vasp

BiTe1 = read('POSCAR_BiTe1')
BiTe2 = read('POSCAR_BiTe2')
BiTe3 = read('POSCAR_BiTe3')

Ag = make_supercell(read('POSCAR_Ag'),P=[[2,0,0],[0,2,0],[0,0,3]])
BiTe1_Ag = stack(Ag,BiTe1,axis=2,fix=0.5)
BiTe2_Ag = stack(Ag,BiTe2,axis=2,fix=0.5)
BiTe3_Ag = stack(Ag,BiTe3,axis=2,fix=0.5)

write('POSCAR_BiTe1_Ag',BiTe1_Ag,format='vasp')
write('POSCAR_BiTe2_Ag',BiTe2_Ag,format='vasp')
write('POSCAR_BiTe3_Ag',BiTe3_Ag,format='vasp')
&lt;/code&gt;&lt;/pre&gt;
&lt;img src="https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/spl1.png"/&gt;
&lt;h5 id="关于ase中stack函数的原理"&gt;关于ase中stack函数的原理。&lt;/h5&gt;
&lt;p&gt;将两个周期性的晶胞合并成一个周期性的晶胞，有一个必须要面对的问题，那就是接触面将不再有周期性。&lt;/p&gt;</description></item><item><title>随机取代晶体结构中的元素</title><link>https://liubaoshuai1402.github.io/dft/%E9%9A%8F%E6%9C%BA%E5%8F%96%E4%BB%A3%E5%85%83%E7%B4%A0/</link><pubDate>Wed, 16 Jul 2025 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/%E9%9A%8F%E6%9C%BA%E5%8F%96%E4%BB%A3%E5%85%83%E7%B4%A0/</guid><description>&lt;h1 id="从一个实例中学习python中的排列组合的实现"&gt;从一个实例中学习python中的排列组合的实现&lt;/h1&gt;
&lt;h2 id="zro2中掺杂y元素"&gt;ZrO2中掺杂Y元素&lt;/h2&gt;
&lt;p&gt;一个96原子的晶胞，去掉一个氧空位，再取代两个Zr原子，就是一个通用的YSZ模型（95 原子）。&lt;/p&gt;
&lt;p&gt;但是Y与Vo的相对位置，是一个麻烦。&lt;/p&gt;
&lt;p&gt;Y的掺杂会不会带来晶胞大小的变化。我这里的处理是根据以往的文献，确定一个可能的构型。&lt;/p&gt;
&lt;p&gt;然后考虑一下掺杂对晶胞尺寸带来的影响，然后就定了，Y再换其他位置也认为不会再影响了。（因为比起相对位置，肯定有无Y原子才是影响的大头）&lt;/p&gt;
&lt;p&gt;确定了晶胞尺寸，结构优化后，再把Y换成Zr。然后随机取代，最终确定$C_{32}^2$个结构，计算单点能，用于机器学习势学习。&lt;/p&gt;
&lt;h3 id="代码"&gt;代码&lt;/h3&gt;
&lt;p&gt;由大G老师支持。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ase.io import read
from ase.io.vasp import write_vasp
from itertools import combinations
import os

at = read('POSCAR')


# 找到所有 Zr 原子的索引
zr_indices = [i for i, atom in enumerate(at) if atom.symbol == 'Zr']
print(f&amp;quot;找到 {len(zr_indices)} 个 Zr 原子&amp;quot;)

# 创建保存目录
os.makedirs(&amp;quot;ZrO_Y2_structures&amp;quot;, exist_ok=True)

# 枚举所有 Zr 的两两组合，逐个替换为 Y
for count, (i, j) in enumerate(combinations(zr_indices, 2)):
 new_at = at.copy()
 new_at[i].symbol = 'Y'
 new_at[j].symbol = 'Y'

 # 写入文件 
 subdir = f&amp;quot;ZrO_Y2_structures/{count}&amp;quot;
 os.makedirs(subdir, exist_ok=True)
 filename = os.path.join(subdir, &amp;quot;POSCAR&amp;quot;)
 write_vasp(filename, new_at,direct=True,sort=True)
 print(f&amp;quot;写入结构：{filename}&amp;quot;)

print(f&amp;quot;共生成 {count + 1} 个结构。&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;combations&lt;/code&gt;类是python中实现组合的高效方式。参数为一个列表，一个长度。返回一个包含若干元组的列表。&lt;/p&gt;</description></item><item><title>COHP</title><link>https://liubaoshuai1402.github.io/dft/cohp/</link><pubDate>Sat, 28 Jun 2025 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/cohp/</guid><description>&lt;h1 id="cohp"&gt;COHP&lt;/h1&gt;
&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;h3 id="vasp文件的准备"&gt;VASP文件的准备&lt;/h3&gt;
&lt;p&gt;LOBSTER要求ISYM=0或-1。其他参数没有特殊要求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构优化&lt;/p&gt;
&lt;p&gt;略过&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;静态自洽&lt;/p&gt;
&lt;p&gt;以较为简单的K点设置计算波函数、电荷密度。&lt;/p&gt;
&lt;p&gt;用于得到WAVECAR、CHGCAR&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#关键参数
ISTART = 0 
ICHARG = 2
NSW = 0
NBANDS = 500	#这个值要大，多试试
NEDOS = 1000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后续的非静态自洽的NBANDS和NEDOS尽量和这里保持一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非静态自洽&lt;/p&gt;
&lt;p&gt;不再更新波函数和电荷密度，进行一次单次的求解。&lt;/p&gt;
&lt;p&gt;这里可以设置更密的K点来求态密度，也可以设置特殊路径的K点来求能带结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#关键参数
ISTART = 1 # 使用前一轮的波函数
ICHARG = 11 # 使用前一轮的电荷密度，不再更新
NSW = 0
LORBIT = 12
NBANDS = 500	#这个值要大，多试试
NEDOS = 1000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特别说一下LORBIT参数，这个参数是后处理参数，和VASP的电子计算无关。&lt;/p&gt;
&lt;p&gt;指示VASP生成：DOSCAR and lm-decomposed PROCAR + phase factors (not recommended)&lt;/p&gt;
&lt;p&gt;所以只需要最后非静态自洽的时候设置即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，如果对精度不高，或者不考虑成本，我看也有人直接用静态自洽的结果（这里直接设置比较高的K点密度）进行LOBSTER。&lt;/p&gt;
&lt;p&gt;如果用的&lt;code&gt;ISMEAR = 0&lt;/code&gt;，后续要在lobsterin文件中指出。&lt;/p&gt;</description></item><item><title>用VASP进行第一性原理分子动力学（AIMD）</title><link>https://liubaoshuai1402.github.io/dft/aimd/</link><pubDate>Sat, 28 Jun 2025 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/aimd/</guid><description>&lt;h1 id="aimd"&gt;AIMD&lt;/h1&gt;
&lt;h3 id="nvt系综"&gt;nvt系综&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ISTART = 0
ENCUT = 480
PREC = Normal
ALGO = Fast
LREAL = Auto
LWAVE = .F. 
LCHARG = .F.
GGA = PS
ISMEAR = 0
SIGMA = 0.05
ISPIN = 1

#electronstep
NELM = 200
NELMIN = 4
EDIFF = 1E-4

#AIMD
IBRION = 0 
MDALGO = 2 
ISIF = 2 
TEBEG = 1500 
NSW = 5000 
POTIM = 0.5 
SMASS = 0.5

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IBRION&lt;/code&gt;是控制离子步优化算法的参数，进行分子动力学是设置为0。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MDALGO&lt;/code&gt;这个参数控制恒温器选项。&lt;/p&gt;</description></item></channel></rss>