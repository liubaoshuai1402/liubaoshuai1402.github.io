<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>机器学习势 on BOGHTW</title>
    <link>https://liubaoshuai1402.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/</link>
    <description>Recent content in 机器学习势 on BOGHTW</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 18 Jun 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://liubaoshuai1402.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DeepMD入门</title>
      <link>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/deepmd%E5%85%A5%E9%97%A8/</link>
      <pubDate>Wed, 18 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/deepmd%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h1 id=&#34;deepmd入门&#34;&gt;DeepMD入门&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;之前一直用的mace，现在来了解一下deepmd吧。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1dp的数据集结构&#34;&gt;1.dp的数据集结构&lt;/h3&gt;&#xA;&lt;p&gt;与mace相对简单的数据集结构相比（只需提供打标签后xyz文件），dp组织它的数据集以一种相对不自由的形式，但也更加清楚明了。&lt;/p&gt;&#xA;&lt;p&gt;dp的数据集是由dpdata处理DFT结果得到的。一个标准的dp数据集路径下，包含了三种文件，分别是：&lt;code&gt;type.raw&lt;/code&gt;、&lt;code&gt;type_map.raw&lt;/code&gt;和&lt;code&gt;set.000&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;type.raw&lt;/code&gt;其实就是POSCAR中的原子，只不过把元素符号换成了数字。&lt;code&gt;type_map.raw&lt;/code&gt;则是保留了数字到元素符号的映射关系。&lt;/p&gt;&#xA;&lt;p&gt;&lt;del&gt;很困惑为什么要这样设计&lt;/del&gt;&lt;/p&gt;&#xA;&lt;p&gt;set.000文件夹则是存放DFT标签的，具体如坐标、能量、力等。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2如何生成数据集&#34;&gt;2.如何生成数据集&lt;/h3&gt;&#xA;&lt;p&gt;任务：想象一下，你有多个OUTCAR，分别是：&lt;/p&gt;&#xA;&lt;p&gt;1000K下：C、O体系；C、O、H体系&lt;/p&gt;&#xA;&lt;p&gt;2000K下：C、O体系；C、O、H体系&lt;/p&gt;&#xA;&lt;p&gt;如何把他们整合成训练集和数据集呢？&lt;/p&gt;&#xA;&lt;p&gt;每个体系AIMD的OUTCAR包含10000个轨迹。但因为相邻轨迹的结构比较接近，我们决定每100步取一个结构作为数据集。&lt;/p&gt;&#xA;&lt;p&gt;现在你有以下路径，&lt;code&gt;1000K/CO/OUTCAR&lt;/code&gt;、&lt;code&gt;1000K/COH/OUTCAR&lt;/code&gt;、&lt;code&gt;2000K/CO/OUTCAR&lt;/code&gt;、&lt;code&gt;2000K/COH/OUTCAR&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;此外呢，如果把这四体系合并后再划分训练集、验证集，随机性会更大，比如说某个体系的训练集取得很多，而某个体系则几乎全被当作验证集。&lt;/p&gt;&#xA;&lt;p&gt;为了避免这样的事情发生，我们可以先把每个体系划分成小的训练集、验证区，然后把这些小的训练集、验证集合并。&lt;/p&gt;&#xA;&lt;p&gt;这就是总体思路，来看看怎么实现吧。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import dpdata&#xD;&#xA;import numpy as np&#xD;&#xA;#生成一个列表用于dpdata取子集的索引，dpdata的system并不支持直接的切片规则，很无语&#xD;&#xA;#从第1个结构到1w个，每100步取一个，很灵活，可以自由改变起始，结束和步长&#xD;&#xA;IndicesInitial = list(range(0,10000,100))&#xD;&#xA;#从100个结构的索引中随机取20个作为验证集，20%&#xD;&#xA;np.random.seed(42)&#xD;&#xA;ValidIndices = list(np.random.choice(IndicesInitial,20,replace=None))&#xD;&#xA;#从数据集中剔除验证集，得到训练集，这里为了实现列表元素进行集合运算，先把他们变成集合&#xD;&#xA;TrainIndices = list(set(IndicesInitial)-set(ValidIndices))&#xD;&#xA;#只读了一个OUTCAR作为例子，适当修改&#xD;&#xA;dpSystem = dpdata.LabeledSystem(&#39;1000K/CO/OUTCAR&#39;)&#xD;&#xA;&#xD;&#xA;dpSystemTrain = dpSystem.sub_system(TrainIndices)&#xD;&#xA;dpSystemTrain.to(&amp;quot;deepmd/npy&amp;quot;, &amp;quot;trainset/1000K/CO&amp;quot;, set_size=dpSystemTrain.get_nframes())&#xD;&#xA;&#xD;&#xA;dpSystemValid = dpSystem.sub_system(ValidIndices)&#xD;&#xA;dpSystemValid.to(&amp;quot;deepmd/npy&amp;quot;, &amp;quot;validset/1000K/CO&amp;quot;, set_size=dpSystemValid.get_nframes())&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;set_size=dpSystemTrain.get_nframes()&lt;/code&gt;,关于set的尺寸为什么要正好等于所有结构，这个问题追溯起来非常远古。&lt;/p&gt;&#xA;&lt;p&gt;曾经dp的开发者应该希望一个system下有多个set.00x，最后一个set.00x作为测试集。但后来他们放弃了。&lt;/p&gt;&#xA;&lt;p&gt;所以现在的用法是，只要一个set.000即可，至于这个system下的数据用于训练、验证，在input.json中说明即可。&lt;/p&gt;&#xA;&lt;p&gt;顺带一提，dp训练模型时并不要求测试集，mace的话则可以提供。&lt;/p&gt;&#xA;&lt;p&gt;下图是input.json的一部分：&lt;/p&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/dp1.png&#34; style=&#34;zoom:67%;&#34; /&gt;&#xD;&#xA;&lt;p&gt;把相应路径替换成&lt;code&gt;&amp;quot;trainset/1000K/CO&amp;quot;&lt;/code&gt;等等即可&lt;/p&gt;&#xA;&lt;p&gt;dp中system的概念，同一个system中，结构涉及的元素和原子个数应该完全相同。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3利用dpdata生成扰动结构&#34;&gt;3.利用dpdata生成扰动结构&lt;/h3&gt;&#xA;&lt;p&gt;dpdata本身已经提供了很好的&#xD;&#xA;&lt;a href=&#34;https://docs.deepmodeling.com/projects/dpdata/en/master/systems/system.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;示例&lt;/a&gt;&#xD;&#xA;, 这里简单搬运一下，并添加了一个更深入的应用场景。&lt;/p&gt;</description>
    </item>
    <item>
      <title>绘制DFT数据和MACE预测值的关系图</title>
      <link>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/dft%E6%95%B0%E6%8D%AEvsmace%E9%A2%84%E6%B5%8B%E5%80%BC/</link>
      <pubDate>Thu, 29 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/dft%E6%95%B0%E6%8D%AEvsmace%E9%A2%84%E6%B5%8B%E5%80%BC/</guid>
      <description>&lt;h1 id=&#34;绘制dft数据和mace预测值的关系图&#34;&gt;绘制DFT数据和MACE预测值的关系图&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;本文主要搬运一下&#xD;&#xA;&lt;a href=&#34;https://colab.research.google.com/drive/1ZrTuTvavXiCxTFyjBV4GqlARxgFwYAtX#scrollTo=v75wGSfOw9dA&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;MACE教程其一&lt;/a&gt;&#xD;&#xA;，记录一下如何绘制DFT数据和MACE预测值的关系图，用于评估模型的准确性，加上一些自己的理解。&lt;/p&gt;&#xA;&lt;p&gt;软件：ASE、&#xD;&#xA;&lt;a href=&#34;https://github.com/imagdau/aseMolec&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;aseMolec&lt;/a&gt;&#xD;&#xA;、matplotlib、numpy&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;准备评估函数&#34;&gt;准备评估函数&lt;/h2&gt;&#xA;&lt;p&gt;MACE官方写好了评估的命令行脚本，我们这里给它一个虚拟参数，方便以编程的方式调用它。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from mace.cli.eval_configs import main as mace_eval_configs_main&#xD;&#xA;import sys&#xD;&#xA;&#xD;&#xA;def eval_mace(configs, model, output):&#xD;&#xA;    sys.argv = [&amp;quot;program&amp;quot;, &amp;quot;--configs&amp;quot;, configs, &amp;quot;--model&amp;quot;, model, &amp;quot;--output&amp;quot;, output]&#xD;&#xA;    mace_eval_configs_main()&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这里的&lt;code&gt;eval_mace&lt;/code&gt;函数接受三个参数，数据集如训练集、测试集的路径、训练好的模型的路径以及输出的文件命。&lt;/p&gt;&#xA;&lt;h2 id=&#34;评估数据集&#34;&gt;评估数据集&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#evaluate the training set&#xD;&#xA;eval_mace(configs=&amp;quot;data/solvent_xtb_train_200.xyz&amp;quot;,&#xD;&#xA;          model=&amp;quot;MACE_models/mace01_run-123_stagetwo.model&amp;quot;,&#xD;&#xA;          output=&amp;quot;tests/mace01/solvent_train.xyz&amp;quot;)&#xD;&#xA;&#xD;&#xA;#evaluate the test set&#xD;&#xA;eval_mace(configs=&amp;quot;data/solvent_xtb_test.xyz&amp;quot;,&#xD;&#xA;          model=&amp;quot;MACE_models/mace01_run-123_stagetwo.model&amp;quot;,&#xD;&#xA;          output=&amp;quot;tests/mace01/solvent_test.xyz&amp;quot;)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这样，MACE就会对数据集进行评估，因为其实DFT数据是已有的，主要是在输出文件中，补上MACE的预测值。&lt;/p&gt;&#xA;&lt;h2 id=&#34;画图&#34;&gt;画图&lt;/h2&gt;&#xA;&lt;p&gt;然后就可以用aseMolec的如下代码进行画图了&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from aseMolec import pltProps as pp&#xD;&#xA;from ase.io import read&#xD;&#xA;import matplotlib.pyplot as plt&#xD;&#xA;from aseMolec import extAtoms as ea&#xD;&#xA;import numpy as np&#xD;&#xA;&#xD;&#xA;def plot_RMSEs(db, labs):&#xD;&#xA;    ea.rename_prop_tag(db, &#39;MACE_energy&#39;, &#39;energy_mace&#39;) #Backward compatibility&#xD;&#xA;    ea.rename_prop_tag(db, &#39;MACE_forces&#39;, &#39;forces_mace&#39;) #Backward compatibility&#xD;&#xA;&#xD;&#xA;    plt.figure(figsize=(9,6), dpi=100)&#xD;&#xA;    plt.subplot(1,3,1)&#xD;&#xA;    pp.plot_prop(ea.get_prop(db, &#39;bind&#39;, &#39;_xtb&#39;, True).flatten(), \&#xD;&#xA;                 ea.get_prop(db, &#39;bind&#39;, &#39;_mace&#39;, True).flatten(), \&#xD;&#xA;                 title=r&#39;Energy $(\rm eV/atom)$ &#39;, labs=labs, rel=False)&#xD;&#xA;    plt.subplot(1,3,2)&#xD;&#xA;    pp.plot_prop(ea.get_prop(db, &#39;info&#39;, &#39;energy_xtb&#39;, True).flatten(), \&#xD;&#xA;                 ea.get_prop(db, &#39;info&#39;, &#39;energy_mace&#39;, True).flatten(), \&#xD;&#xA;                 title=r&#39;Energy $(\rm eV/atom)$ &#39;, labs=labs, rel=False)&#xD;&#xA;    plt.subplot(1,3,3)&#xD;&#xA;    pp.plot_prop(np.concatenate(ea.get_prop(db, &#39;arrays&#39;, &#39;forces_xtb&#39;)).flatten(), \&#xD;&#xA;                 np.concatenate(ea.get_prop(db, &#39;arrays&#39;, &#39;forces_mace&#39;)).flatten(), \&#xD;&#xA;                 title=r&#39;Forces $\rm (eV/\AA)$ &#39;, labs=labs, rel=False)&#xD;&#xA;    plt.tight_layout()&#xD;&#xA;    return&#xD;&#xA;&#xD;&#xA;train_data = read(&#39;tests/mace01/solvent_train.xyz&#39;, &#39;:&#39;)&#xD;&#xA;test_data = train_data[:3]+read(&#39;tests/mace01/solvent_test.xyz&#39;, &#39;:&#39;) #append the E0s for computing atomization energy errors&#xD;&#xA;&#xD;&#xA;plot_RMSEs(train_data, labs=[&#39;XTB&#39;, &#39;MACE&#39;])&#xD;&#xA;plot_RMSEs(test_data, labs=[&#39;XTB&#39;, &#39;MACE&#39;])&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;plot_RMSEs&lt;/code&gt;函数中首先把标签重命名了一下，因为MACE的源代码&lt;code&gt;mace_eval_configs_main()&lt;/code&gt;部分默认打的标签是&lt;code&gt;MACE_&lt;/code&gt;+什么什么的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何构建训练集用于训练机器学习势</title>
      <link>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/mace1/</link>
      <pubDate>Fri, 16 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/mace1/</guid>
      <description>&lt;h1 id=&#34;如何构建训练集用于训练机器学习势&#34;&gt;如何构建训练集用于训练机器学习势&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;本文将介绍如何构建一个训练集，用于训练MACE势以及DP势。需要提前利用AIMD获取DFT数据集。这里的AIMD软件是VASP。&lt;/p&gt;&#xA;&lt;p&gt;软件：ASE、DeepMD-Kit&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;构建mace势的训练集&#34;&gt;构建MACE势的训练集&lt;/h2&gt;&#xA;&lt;p&gt;MACE接受的训练集非常简单，一个&lt;code&gt;xyz&lt;/code&gt;文件，包含了各种构型和它们对应的DFT数据标签，以及单原子的DFT数据，需要额外的标签&lt;code&gt;config_type=IsolatedAtom&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;顺带一提，ASE可以输出一种所谓的&#xD;&#xA;&lt;a href=&#34;https://wiki.fysik.dtu.dk/ase/ase/io/formatoptions.html#extxyz&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;Extended XYZ format&lt;/a&gt;&#xD;&#xA;，会把各种各样的信息（有点类似OVITO中的全局信息），放到&lt;code&gt;xyz&lt;/code&gt;文件的第二行。这一行会很长很长。MACE所采用的训练集输入格式就是它。&lt;/p&gt;&#xA;&lt;p&gt;假设我们要构建水分子的MACE势，当前所处的路径下，有两个文件夹。&lt;/p&gt;&#xA;&lt;p&gt;一个名为&lt;code&gt;H2O&lt;/code&gt;的文件夹，里面存放着进行第一性原理分子动力学后得到的&lt;code&gt;OUTCAR.tar.gz&lt;/code&gt;文件。路径为&lt;code&gt;H2O/OUTCAR.tar.gz&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;一个名为&lt;code&gt;IsolatedAtoms&lt;/code&gt;的文件夹，里面存放着涉及元素（这里是H、O）的单原子的单点能计算（ISPIN=2）。路径分别为&lt;code&gt;IsolatedAtoms/H/OUTCAR.tar.gz&lt;/code&gt;和&lt;code&gt;IsolatedAtoms/O/OUTCAR.tar.gz&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;代码展示&#34;&gt;代码展示&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ase.io import read,write&#xD;&#xA;import random&#xD;&#xA;&#xD;&#xA;#定义一个简单的函数用于打标签,这里可以自由更改标签的名字&#xD;&#xA;def addlabel(configs,energy_label=&#39;energy_dft&#39;,forces_label=&#39;forces_dft&#39;,stress_label=&#39;stress_dft&#39;,is_isolated=False):&#xD;&#xA;    if is_isolated == False:&#xD;&#xA;        for at in configs:&#xD;&#xA;            at.info[energy_label] = at.get_potential_energy(force_consistent=True)&#xD;&#xA;            at.arrays[forces_label] = at.get_forces()&#xD;&#xA;            at.info[stress_label] = at.get_stress(voigt=True)&#xD;&#xA;    if is_isolated == True:&#xD;&#xA;        for at in configs:&#xD;&#xA;            at.info[&#39;config_type&#39;] = &#39;IsolatedAtom&#39;&#xD;&#xA;            at.info[energy_label] = at.get_potential_energy(force_consistent=True)&#xD;&#xA;            at.arrays[forces_label] = at.get_forces()&#xD;&#xA;            at.info[stress_label] = at.get_stress(voigt=True)&#xD;&#xA;&#xD;&#xA;#read()函数，这里，第一个参数是所读文件路径，第二个参数是切片slice&#xD;&#xA;IsolatedH = read(&#39;IsolatedAtoms/H/OUTCAR.tar.gz&#39;,&#39;:&#39;)&#xD;&#xA;IsolatedO = read(&#39;IsolatedAtoms/O/OUTCAR.tar.gz&#39;,&#39;:&#39;)&#xD;&#xA;IsolatedAtoms = IsolatedH + IsolatedO&#xD;&#xA;addlabel(configs=IsolatedAtoms,is_isolated=True)&#xD;&#xA;&#xD;&#xA;#这里的slice的意思是从第一个结构开始到最后一个结构，每100个结构取一个&#xD;&#xA;db = read(&#39;H2O/OUTCAR.tar.gz&#39;,&#39;::100&#39;)&#xD;&#xA;addlabel(configs=db)&#xD;&#xA;&#xD;&#xA;#打乱训练集，这对训练非常重要&#xD;&#xA;random.seed(42)&#xD;&#xA;random.shuffle(db)&#xD;&#xA;&#xD;&#xA;#将打过标签的数据集合并&#xD;&#xA;db = db + IsolatedAtoms&#xD;&#xA;write(&#39;trainset.xyz&#39;,db)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这里有趣的一点是，为什么对于单个结构的&lt;code&gt;OUTCAR&lt;/code&gt;，也要进行切片：&lt;code&gt;IsolatedH = read(&#39;IsolatedAtoms/H/OUTCAR.tar.gz&#39;,&#39;:&#39;)&lt;/code&gt;，而不是&lt;code&gt;IsolatedH = read(&#39;IsolatedAtoms/H/OUTCAR.tar.gz&#39;)&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>机器学习势MACE的输入文件</title>
      <link>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/mace2/</link>
      <pubDate>Fri, 16 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/mace2/</guid>
      <description>&lt;h1 id=&#34;机器学习势mace的输入文件&#34;&gt;机器学习势MACE的输入文件&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;不同MACE版本的参数设置会有一定的调查，注意查看自己的MACE版本。这里是0.3.13版本&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;在超算上用slurm提交python任务&#34;&gt;在超算上用slurm提交python任务&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash&#xD;&#xA;#SBATCH -o job.%j.out&#xD;&#xA;#SBATCH -J lmp_job_gpu&#xD;&#xA;#SBATCH --partition=gpu        &#xD;&#xA;#SBATCH -N 1                    &#xD;&#xA;#SBATCH -G 1&#xD;&#xA;#SBATCH --gres=gpu:1&#xD;&#xA;#SBATCH --exclusive&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;export PATH=/home-ssd/Users/nsgm_zcx/openmpi-5.0.5/build/bin:$PATH&#xD;&#xA;export LD_LIBRARY_PATH=/home-ssd/Users/nsgm_zcx/openmpi-5.0.5/build/lib:$LD_LIBRARY_PATH&#xD;&#xA;export PATH=/home-ssd/Users/nsgm_zcx/lammps-develop/build-mliap:$PATH&#xD;&#xA;&#xD;&#xA;source /home-ssd/Users/nsgm_zcx/miniconda3/etc/profile.d/conda.sh&#xD;&#xA;conda activate cuda&#xD;&#xA;&#xD;&#xA;mace_run_train --config parameters.yaml&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;前面几行是为了激活lammps和openmpi，在这里没啥用。&lt;/p&gt;&#xA;&lt;p&gt;重要的是要在sh脚本里激活conda，然后用&lt;code&gt;mace_run_train&lt;/code&gt;命令行脚本来提交训练任务。&lt;/p&gt;&#xA;&lt;p&gt;用&lt;code&gt;--config&lt;/code&gt;参数和一个yaml文件来提供训练参数。&lt;/p&gt;&#xA;&lt;p&gt;以下是&lt;code&gt;parameters.yaml&lt;/code&gt;的内容&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: YSZH_MACE_model&#xD;&#xA;seed: 123&#xD;&#xA;device: cuda&#xD;&#xA;train_file: train.xyz&#xD;&#xA;valid_fraction: 0.2&#xD;&#xA;test_file: test.xyz&#xD;&#xA;compute_forces: True&#xD;&#xA;compute_stress: True&#xD;&#xA;energy_key: energy_vasp&#xD;&#xA;forces_key: forces_vasp&#xD;&#xA;stress_key: stress_vasp&#xD;&#xA;E0s: &#39;isolated&#39;&#xD;&#xA;hidden_irreps: &#39;64x0e + 64x1o&#39;&#xD;&#xA;r_max: 4.0&#xD;&#xA;batch_size: 20&#xD;&#xA;max_num_epochs: 600&#xD;&#xA;swa: True&#xD;&#xA;start_swa: 480&#xD;&#xA;ema: True&#xD;&#xA;ema_decay: 0.99&#xD;&#xA;default_dtype: float32&#xD;&#xA;lr: 0.01&#xD;&#xA;scaling: rms_forces_scaling&#xD;&#xA;multiheads_finetuning: False&#xD;&#xA;enable_cueq: True&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;要使用&lt;code&gt;mliap&lt;/code&gt;，就必须打开参数&lt;code&gt;enable_cueq: True&lt;/code&gt;，并确保python环境中安装了&lt;code&gt;cuEquivariance&lt;/code&gt;和&lt;code&gt;cupy&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
