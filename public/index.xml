<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BOGHTW</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on BOGHTW</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 24 May 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>晶界建模</title>
      <link>http://localhost:1313/pymatgen/gainbroundary/</link>
      <pubDate>Sat, 24 May 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/pymatgen/gainbroundary/</guid>
      <description>&lt;h1 id=&#34;晶界建模&#34;&gt;晶界建模&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;基于&#xA;&lt;a href=&#34;https://dtrinkle.matse.illinois.edu/MatSE584/kap_7/backbone/r7_1_2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;共格点阵模型&lt;/a&gt;&#xA;（Coincidence Site Lattice），使用pymatgen进行晶界建模。&lt;/p&gt;&#xA;&lt;h2 id=&#34;晶界的类型&#34;&gt;晶界的类型&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-扭转twist晶界&#34;&gt;1. 扭转（twist）晶界&lt;/h3&gt;&#xA;&lt;p&gt;旋转轴垂直于晶界面，也就是两者的密勒指数应该成比列。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-倾斜tilt晶界&#34;&gt;2. 倾斜（tilt）晶界&lt;/h3&gt;&#xA;&lt;p&gt;旋转轴平行于晶界面，也就是两者的密勒指数的点乘为0。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-混合mixed晶界&#34;&gt;3. 混合（mixed）晶界&lt;/h3&gt;&#xA;&lt;p&gt;旋转轴既不垂直也不平行于晶界面。&lt;/p&gt;&#xA;&lt;p&gt;基于共格点阵模型的晶界命名法，Σ+number(must be odd)+(hkl)/[uvw]。&lt;/p&gt;&#xA;&lt;p&gt;举一个栗子， Σ13 (510)/[001] symmetric tilt grain-boundary。&lt;/p&gt;&#xA;&lt;p&gt;这里Σ的大小，是指旋转后重合点阵的单胞的提及是原始晶体单胞的体积的多少倍。通常，这个数字越大，代表两个晶粒的取向相差越远，晶界能也往往越远。&lt;/p&gt;&#xA;&lt;p&gt;Σ1则代表趋向一致，那些小角度晶界也被认为Σ的值近似于1。&lt;/p&gt;&#xA;&lt;p&gt;当指明是twist or tilt晶界时，有时可以省略晶向，也不会造成歧义，比如，&lt;mark&gt;the Σ5(310) tilt GB&lt;/mark&gt;，这是一个YSZ中典型的低能量晶界。&lt;/p&gt;&#xA;&lt;p&gt;但它没有给出旋转轴，因为没有必要，tilt GB 要求晶界面与旋转轴平行，所以只能是[001]。&lt;/p&gt;&#xA;&lt;h2 id=&#34;使用pymatgen进行晶界建模&#34;&gt;使用pymatgen进行晶界建模&lt;/h2&gt;&#xA;&lt;p&gt;首先，我们假设一个应用场景，就是说，我们建模肯定是根据实验来的，实验上对哪些晶界感兴趣，我们就去建模研究。&lt;/p&gt;&#xA;&lt;p&gt;所以在这个假设的基础上，我们是知道&lt;mark&gt;Σ的值&lt;/mark&gt;以及&lt;mark&gt;旋转轴&lt;/mark&gt;、&lt;mark&gt;晶界面&lt;/mark&gt;的。&lt;/p&gt;&#xA;&lt;p&gt;这样，用以下代码我们可以得到旋转角。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pymatgen.core import Structure&#xD;&#xA;from pymatgen.core.interface import GrainBoundaryGenerator&#xD;&#xA;&#xD;&#xA;# 1. 读取结构文件&#xD;&#xA;structure = Structure.from_file(&amp;quot;ZrO.cif&amp;quot;)&#xD;&#xA;structure = structure.to_conventional()&#xD;&#xA;&#xD;&#xA;#创建一个晶界生成器，实例化需要一个晶体结构，最好是conventional cell。&#xD;&#xA;gb_gen = GrainBoundaryGenerator(structure)&#xD;&#xA;&#xD;&#xA;# 2. 构建 Σ5 晶界，参数分别对应Σ的值、旋转轴、晶格类型，对非立方体系需要指定轴比&#xD;&#xA;#其实这里感觉很奇怪，轴比和晶格类型，pymatgen不应该自己判断吗，感觉这块代码写的不好&#xD;&#xA;rotation_anglen = gb_gen.get_rotation_angle_from_sigma(5,(0,0,1),lat_type=&#39;c&#39;)&#xD;&#xA;print(rotation_anglen)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这里的输出是，[36.86989764584402, 53.13010235415597, 126.86989764584402, 143.13010235415598]。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Pytorch中的张量操作</title>
      <link>http://localhost:1313/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%BC%A0%E9%87%8F%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 20 May 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%BC%A0%E9%87%8F%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;h1 id=&#34;pytorch中的张量操作&#34;&gt;Pytorch中的张量操作&lt;/h1&gt;&#xA;&lt;h2 id=&#34;数学符号&#34;&gt;数学符号&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1--运算符&#34;&gt;1. * 运算符&lt;/h3&gt;&#xA;&lt;p&gt;如果张量的形状完全一样，张量 * 张量，其实就是对应元素相乘，也可以$\odot$表示。&lt;/p&gt;&#xA;&lt;p&gt;如果张量的形状不一样，则要求他们的形状只能在一个维度上不一样，且其中一个张量这个维度的&lt;code&gt;size&lt;/code&gt;为1，这样可以用广播机制补全后相乘。&lt;/p&gt;&#xA;&lt;p&gt;如果张量 * 数字，则是全体元素乘以这个数字。&lt;/p&gt;&#xA;&lt;h2 id=&#34;函数方法&#34;&gt;函数、方法&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-permute&#34;&gt;1. &lt;code&gt;permute()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;可以作为张量对象的方法使用，接受置换后的维度。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch&#xD;&#xA;&#xD;&#xA;table = torch.randn(2,3,4)&#xD;&#xA;print(table)&#xD;&#xA;print(table.permute(2,1,0))&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这段代码就是将第一维和第三维进行置换。&lt;/p&gt;&#xA;&lt;p&gt;由已知的张量还有置换后的顺序，怎么写出新的张量呢，这个问题一直让我困扰。&lt;/p&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/permute.jpg&#34; style=&#34;zoom:50%;&#34; /&gt;&#xD;&#xA;&lt;p&gt;今天的学习，我脑子里突然蹦出一个邻居的概念。对于一个四维的张量元素，它应该有四个不同维度的邻居，但如果仅仅把视角局限在矩阵里，那它就只有两个邻居，一个行维度上的，一个列维度上的，这很不对。得把视野打开，通道维度和批次维度的邻居可能隔了很远，但它们也是邻居。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-reshape和view&#34;&gt;2. &lt;code&gt;reshape()&lt;/code&gt;和&lt;code&gt;view()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;深度学习中，经常会把高维张量降维，计算后再展开，要小心翼翼，错位会带来灾难性的错误。&lt;/p&gt;&#xA;&lt;p&gt;对于一个（N，F，M）的张量，F是其特征维度。如果想把N和M合并，&lt;mark&gt;应该先把F变成最高维度或者最低维度，让需要合并的维度接壤&lt;/mark&gt;。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch&#xD;&#xA;&#xD;&#xA;table = torch.randn(2,3,4)&#xD;&#xA;print(table)&#xD;&#xA;a = table.reshape(3,8)&#xD;&#xA;b = table.permute(1,0,2).reshape(3,8)&#xD;&#xA;&#xD;&#xA;print(a)&#xD;&#xA;print(b)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这里先把张量形状变成了（3，2，4），再合并，可以保证张量维度不会错位，如果直接改写性质为（3，8），则会错位。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;reshape()&lt;/code&gt;和&lt;code&gt;view()&lt;/code&gt;是一样的，前者可以作用于numpy数组。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-flatten&#34;&gt;3. &lt;code&gt;flatten()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;将高维张量展平为一维张量。&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-torchcat&#34;&gt;4. &lt;code&gt;torch.cat()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;把张量按给定的顺序和维度进行拼接，除了拼接维度外，张量必须具有相同的形状。&lt;/p&gt;&#xA;&lt;p&gt;可用于特征维度的拓展，加入新的特征。&lt;/p&gt;&#xA;&lt;h3 id=&#34;5-unsqueeze&#34;&gt;5. &lt;code&gt;unsqueeze()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&#xA;&lt;a href=&#34;https://docs.pytorch.org/docs/stable/generated/torch.unsqueeze.html#torch.unsqueeze&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;torch.unsqueeze&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;torch.unsqueeze(&lt;em&gt;input&lt;/em&gt;, &lt;em&gt;dim&lt;/em&gt;) → Tensor&lt;/p&gt;&#xA;&lt;p&gt;为张量插入一个新的&lt;code&gt;size&lt;/code&gt;为1的维度。用于升维。配合&lt;code&gt;expand()&lt;/code&gt;食用更佳。&lt;/p&gt;&#xA;&lt;h3 id=&#34;6-expand&#34;&gt;6. &lt;code&gt;expand()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&#xA;&lt;a href=&#34;https://docs.pytorch.org/docs/stable/generated/torch.Tensor.expand.html#torch.Tensor.expand&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;torch.Tensor.expand&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;这个只有张量方法，没有函数。&lt;/p&gt;</description>
    </item>
    <item>
      <title>用于搭建神经网络的函数</title>
      <link>http://localhost:1313/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch2/</link>
      <pubDate>Mon, 19 May 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch2/</guid>
      <description>&lt;h1 id=&#34;用于搭建神经网络的函数&#34;&gt;用于搭建神经网络的函数&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;此处记录常见的神经网络函数，排名不分先后。&lt;/p&gt;&#xA;&lt;h2 id=&#34;全连接层&#34;&gt;全连接层&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-nnlinear&#34;&gt;1. &lt;code&gt;nn.Linear()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;对输入数据施加一个仿射线性变换，一般使用指定两个参数，是输入矩阵和输出矩阵的最高维的&lt;code&gt;size&lt;/code&gt;。（因为最高维一般是特征维度，这个函数就是用来控制特征维度&lt;code&gt;size&lt;/code&gt;大小的）&lt;/p&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/%E5%9B%BE%E5%8D%B7%E7%A7%AF.png&#34; style=&#34;zoom:50%;&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里是CGCNN的图卷积操作公式，这里的W（权重），b（偏置）其实全连接层决定的。看到这样的写法就要明白其实是经历了一个全连接层。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;total_gated_fea = self.fc_full(total_nbr_fea)&#xD;&#xA;        &#xD;&#xA;total_gated_fea = self.bn1(total_gated_fea.view(&#xD;&#xA;&#x9;-1, self.atom_fea_len*2)).view(N, M, self.atom_fea_len*2)&#xD;&#xA;nbr_filter, nbr_core = total_gated_fea.chunk(2, dim=2)&#xD;&#xA;nbr_filter = self.sigmoid(nbr_filter)&#xD;&#xA;nbr_core = self.softplus1(nbr_core)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;对应代码就是进过全连接层后，（再进行批标准化，chunk分割，这些公式里没有体现），然后施加$\sigma$函数和激活函数（g）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;激活函数&#34;&gt;激活函数&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-nnrelu&#34;&gt;1. &lt;code&gt;nn.ReLU()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;这个激活函数不用指定输入输出特征的维度，它只是把所有特征变为非负，对于正值保留原始值，对于负值则转化为0。&lt;/p&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/ReLU.png&#34;/&gt;&#xD;&#xA;&lt;h3 id=&#34;2-nnsoftmax&#34;&gt;2. &lt;code&gt;nn.Softmax()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;对一个n维的张量施加Softmax()函数，使得其沿某个维度的元素值的和为1。所以接受一个&lt;code&gt;dim&lt;/code&gt;参数来指定维度。&#xA;&lt;/p&gt;&#xA;$$&#xD;&#xA;\mathrm{Softmax}(x_i)=\frac{\mathrm{exp}(x_i)}{\sum_{j}\mathrm{exp}(x_j)}&#xD;&#xA;$$&lt;p&gt;&#xA;这里简单插入一下Pytorch中有关&lt;code&gt;dim&lt;/code&gt;的实践。&lt;/p&gt;&#xA;&lt;p&gt;比如说一个张量的size是(4,2,3)，那么他的dim=0指的是4，dim=1指的是2，dim=2指的是3。&lt;/p&gt;&#xA;&lt;p&gt;比如说对于这个张量，我有个和Pytorch相反的习惯，我习惯先看每行有多少个元素，是3。我就误以为它的dim=0对应的是3。&lt;/p&gt;&#xA;&lt;p&gt;其实不然，深度学习中，dim最大值对应维度的size，往往对应样本的特征数。&lt;/p&gt;&#xA;&lt;p&gt;一个简单的二维的深度学习的输入张量的size一般是这样的：(batch_size,features)。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([[[0.3299, 0.4336, 0.2365],&#xD;&#xA;         [0.0695, 0.0668, 0.8638]],&#xD;&#xA;&#xD;&#xA;        [[0.8114, 0.1116, 0.0770],&#xD;&#xA;         [0.3142, 0.1086, 0.5772]],&#xD;&#xA;&#xD;&#xA;        [[0.3178, 0.4508, 0.2315],&#xD;&#xA;         [0.1620, 0.2610, 0.5770]],&#xD;&#xA;&#xD;&#xA;        [[0.4454, 0.4082, 0.1464],&#xD;&#xA;         [0.2974, 0.5297, 0.1729]]])&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;3-nnlogsoftmax&#34;&gt;3. &lt;code&gt;nn.LogSoftmax()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;对一个n维的张量施加log(Softmax())函数，通常用于获取对数概率，并与损失函数&lt;code&gt;nn.NLLLoss()&lt;/code&gt;一起使用&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python中的文件操作</title>
      <link>http://localhost:1313/%E4%BB%A3%E7%A0%81/fileoperations/</link>
      <pubDate>Sun, 18 May 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E4%BB%A3%E7%A0%81/fileoperations/</guid>
      <description>&lt;h1 id=&#34;python中的文件操作&#34;&gt;Python中的文件操作&lt;/h1&gt;&#xA;&lt;h3 id=&#34;1获取当前路径&#34;&gt;1.获取当前路径&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;os.getcwd()&lt;/code&gt;可以返回当前工作目录的绝对路径。cwd可以理解成current work directory。&lt;/p&gt;</description>
    </item>
    <item>
      <title>花朵分类</title>
      <link>http://localhost:1313/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch1/</link>
      <pubDate>Sun, 18 May 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch1/</guid>
      <description>&lt;h1 id=&#34;花朵分类&#34;&gt;花朵分类&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;本文主要借助torchvision软件包，简单梳理一下深度学习代码的基本框架。&lt;/p&gt;&#xA;&lt;h2 id=&#34;数据集加载&#34;&gt;数据集加载&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#假设当前工作路径下，存放着一个名为&#39;flower_data&#39;的文件夹，里面存放着训练集和验证集的图片&#xD;&#xA;#用os.path.join()来一级级得获取路径&#xD;&#xA;data_dir = os.path.join(os.getcwd(),&#39;flower_data&#39;)&#xD;&#xA;train_dir = os.path.join(data_dir, &#39;train&#39;)&#xD;&#xA;valid_dir = os.path.join(data_dir, &#39;valid&#39;)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Define batch size&#xD;&#xA;batch_size = 32&#xD;&#xA;&#xD;&#xA;# Define transforms for the training and validation sets&#xD;&#xA;normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406],&#xD;&#xA;                                 std=[0.229, 0.224, 0.225])&#xD;&#xA;&#xD;&#xA;#定义对数据预处理的组合，比如旋转图片、改变尺寸等等，让模型有更强的稳定性&#xD;&#xA;train_data_transforms = transforms.Compose([&#xD;&#xA;        transforms.RandomResizedCrop(size=256, scale=(0.8, 1.0)),&#xD;&#xA;        transforms.RandomRotation(degrees=15),&#xD;&#xA;        transforms.ColorJitter(),&#xD;&#xA;        transforms.RandomHorizontalFlip(),&#xD;&#xA;        transforms.CenterCrop(size=224),&#xD;&#xA;        transforms.ToTensor(),&#xD;&#xA;        normalize,&#xD;&#xA;    ])&#xD;&#xA;&#xD;&#xA;validate_data_transforms = transforms.Compose([&#xD;&#xA;        transforms.Resize(256),&#xD;&#xA;        transforms.CenterCrop(224),&#xD;&#xA;        transforms.ToTensor(),&#xD;&#xA;        normalize,&#xD;&#xA;    ])&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#这里才真正的把图片加载成了二维数据。&#xD;&#xA;train_dataset = datasets.ImageFolder(&#xD;&#xA;    train_dir,&#xD;&#xA;    train_data_transforms)&#xD;&#xA;&#xD;&#xA;validate_dataset = datasets.ImageFolder(&#xD;&#xA;    valid_dir,&#xD;&#xA;    validate_data_transforms)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#做了那么多铺垫，其实就是为了把可用于训练的数据(二维数据)放到 DataLoader 里面&#xD;&#xA;train_loader = torch.utils.data.DataLoader(&#xD;&#xA;    train_dataset, batch_size=batch_size, shuffle=True,&#xD;&#xA;    num_workers=4)&#xD;&#xA;&#xD;&#xA;validate_loader = torch.utils.data.DataLoader(&#xD;&#xA;    validate_dataset, batch_size=batch_size, shuffle=True,&#xD;&#xA;    num_workers=4)&#xD;&#xA;&#xD;&#xA;data_loader = {}&#xD;&#xA;data_loader[&#39;train&#39;] = train_loader&#xD;&#xA;data_loader[&#39;valid&#39;] = validate_loader&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;batch_size&lt;/code&gt;，当训练数据很多时，一次性加载全部数据进行训练会是一种挑战。这时就需要用到批次训练。&lt;code&gt;batch_size&lt;/code&gt;即是一次训练中使用的数据量。注意这里的一次训练，不是指一epoch。只有遍历所有训练集后，才能叫做完成了一代训练。一代训练包含了诸多这样的一次训练。&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用rNEMD方法计算热导率的lammps输入文件</title>
      <link>http://localhost:1313/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/thermal_conductivity_rnemd/</link>
      <pubDate>Fri, 16 May 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/thermal_conductivity_rnemd/</guid>
      <description>&lt;h1 id=&#34;使用rnemd方法计算热导率的lammps输入文件&#34;&gt;使用rNEMD方法计算热导率的LAMMPS输入文件&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&#xA;&lt;a href=&#34;https://doi.org/10.1063/1.473271&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;rNEMD方法&lt;/a&gt;&#xA;，又叫MP方法，计算材料热导率。&lt;/p&gt;&#xA;&lt;p&gt;LAMMPS官方提供了计算脚本，但是使用的单位却是&lt;code&gt;lj&lt;/code&gt;单位制，非常不实用，这里是我自己写的&lt;code&gt;metal&lt;/code&gt;单位制下的脚本。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;in-file&#34;&gt;in file&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# sample LAMMPS input script for thermal conductivity of liquid LJ&#xD;&#xA;# Muller-Plathe method via fix thermal_conductivity&#xD;&#xA;&#xD;&#xA;# settings      temperature, kB and timestep&#xD;&#xA;&#xD;&#xA;variable        t equal 1500&#xD;&#xA;variable        k equal 8.6173e-5 &#xD;&#xA;variable        dt equal 0.0005&#xD;&#xA;&#xD;&#xA;# convert from LAMMPS metal units to SI&#xD;&#xA;variable        eV2J equal 1.6022e-19          #energy convert&#xD;&#xA;variable        A2m equal 1.0e-10           #distance convert&#xD;&#xA;variable        ps2s equal 1.0e-12          #time convert  &#xD;&#xA;variable        convert equal ${eV2J}/${ps2s}/${A2m}          &#xD;&#xA;&#xD;&#xA;# setup problem&#xD;&#xA;&#xD;&#xA;units           metal&#xD;&#xA;atom_style      atomic&#xD;&#xA;atom_modify     map yes&#xD;&#xA;newton          on&#xD;&#xA;read_data       ./333&#xD;&#xA;pair_style      mace no_domain_decomposition&#xD;&#xA;pair_coeff * *  /home-ssd/Users/nsgm_lbs/train/MACE_model/MACE_model_run-123_stagetwo.model-lammps.pt O Zr Y H&#xD;&#xA;neighbor        1.0 bin&#xD;&#xA;neigh_modify    every 500 delay 0 check no&#xD;&#xA;minimize        1e-5 1e-7 1000 1000&#xD;&#xA;timestep        ${dt}&#xD;&#xA;velocity        all create $t 87287&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 1st equilibration run&#xD;&#xA;reset_timestep  0&#xD;&#xA;fix             1 all npt temp $t $t 0.05 iso 0 0 0.5&#xD;&#xA;thermo_style    custom step temp pe etotal enthalpy lx ly lz vol press&#xD;&#xA;thermo          100&#xD;&#xA;run             5000&#xD;&#xA;unfix           1&#xD;&#xA;velocity        all scale $t&#xD;&#xA;fix             1 all nvt temp $t $t 0.05&#xD;&#xA;run             5000&#xD;&#xA;unfix           1&#xD;&#xA;&#xD;&#xA;# 2nd equilibration run&#xD;&#xA;compute         ke all ke/atom&#xD;&#xA;variable        temp atom c_ke/1.5/${k}&#xD;&#xA;&#xD;&#xA;fix             1 all nve&#xD;&#xA;&#xD;&#xA;compute         layers all chunk/atom bin/1d z lower 0.05 units reduced&#xD;&#xA;fix             2 all ave/chunk 10 100 1000 layers v_temp file profile.mp&#xD;&#xA;fix             3 all thermal/conductivity 100 z 20&#xD;&#xA;&#xD;&#xA;variable        tdiff equal f_2[11][3]-f_2[1][3]&#xD;&#xA;thermo_style    custom step temp epair etotal f_3 v_tdiff&#xD;&#xA;thermo_modify   colname f_3 E_delta colname v_tdiff dTemp_step&#xD;&#xA;&#xD;&#xA;thermo          1000&#xD;&#xA;run             20000&#xD;&#xA;&#xD;&#xA;# thermal conductivity calculation&#xD;&#xA;# reset fix thermal/conductivity to zero energy accumulation&#xD;&#xA;fix             3 all thermal/conductivity 100 z 20&#xD;&#xA;variable        start_time equal time&#xD;&#xA;variable        kappa equal (f_3/(time-${start_time})/(lx*ly)/2.0)*(lz/2.0)/f_ave&#xD;&#xA;fix             ave all ave/time 1 1 1000 v_tdiff ave running&#xD;&#xA;thermo_style    custom step temp epair etotal f_3 v_tdiff f_ave&#xD;&#xA;thermo_modify   colname f_3 E_delta colname v_tdiff dTemp_step colname f_ave dTemp&#xD;&#xA;run             20000&#xD;&#xA;print           &amp;quot;Running average thermal conductivity units metal: $(v_kappa)&amp;quot;&#xD;&#xA;variable        tc  equal ${kappa}*${convert}&#xD;&#xA;print           &amp;quot;Running average thermal conductivity units SI: $(v_tc:%.2f)&amp;quot;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>如何构建训练集用于训练机器学习势</title>
      <link>http://localhost:1313/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/mace1/</link>
      <pubDate>Fri, 16 May 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/mace1/</guid>
      <description>&lt;h1 id=&#34;如何构建训练集用于训练机器学习势&#34;&gt;如何构建训练集用于训练机器学习势&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;本文将介绍如何构建一个训练集，用于训练MACE势以及DP势。需要提前利用AIMD获取DFT数据集。这里的AIMD软件是VASP。&lt;/p&gt;&#xA;&lt;p&gt;软件：ASE、DeepMD-Kit&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;构建mace势的训练集&#34;&gt;构建MACE势的训练集&lt;/h2&gt;&#xA;&lt;p&gt;MACE接受的训练集非常简单，一个&lt;code&gt;xyz&lt;/code&gt;文件，包含了各种构型和它们对应的DFT数据标签，以及单原子的DFT数据，需要额外的标签&lt;code&gt;config_type=IsolatedAtom&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;顺带一提，ASE可以输出一种所谓的&#xA;&lt;a href=&#34;https://wiki.fysik.dtu.dk/ase/ase/io/formatoptions.html#extxyz&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;Extended XYZ format&lt;/a&gt;&#xA;，会把各种各样的信息（有点类似OVITO中的全局信息），放到&lt;code&gt;xyz&lt;/code&gt;文件的第二行。这一行会很长很长。MACE所采用的训练集输入格式就是它。&lt;/p&gt;&#xA;&lt;p&gt;假设我们要构建水分子的MACE势，当前所处的路径下，有两个文件夹。&lt;/p&gt;&#xA;&lt;p&gt;一个名为&lt;code&gt;H2O&lt;/code&gt;的文件夹，里面存放着进行第一性原理分子动力学后得到的&lt;code&gt;OUTCAR.tar.gz&lt;/code&gt;文件。路径为&lt;code&gt;H2O/OUTCAR.tar.gz&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;一个名为&lt;code&gt;IsolatedAtoms&lt;/code&gt;的文件夹，里面存放着涉及元素（这里是H、O）的单原子的单点能计算（ISPIN=2）。路径分别为&lt;code&gt;IsolatedAtoms/H/OUTCAR.tar.gz&lt;/code&gt;和&lt;code&gt;IsolatedAtoms/O/OUTCAR.tar.gz&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;代码展示&#34;&gt;代码展示&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ase.io import read,write&#xD;&#xA;&#xD;&#xA;#定义一个简单的函数用于打标签,这里可以自由更改标签的名字&#xD;&#xA;def addlabel(configs,energy_label=&#39;energy_dft&#39;,forces_label=&#39;forces_dft&#39;,stress_label=&#39;stress_dft&#39;,is_isolated=False):&#xD;&#xA;    if is_isolated == False:&#xD;&#xA;        for at in configs:&#xD;&#xA;            at.info[energy_label] = at.get_potential_energy(force_consistent=True)&#xD;&#xA;            at.arrays[forces_label] = at.get_forces()&#xD;&#xA;            at.info[stress_label] = at.get_stress(voigt=True)&#xD;&#xA;    if is_isolated == True:&#xD;&#xA;        for at in configs:&#xD;&#xA;            at.info[&#39;config_type&#39;] = &#39;IsolatedAtom&#39;&#xD;&#xA;            at.info[energy_label] = at.get_potential_energy(force_consistent=True)&#xD;&#xA;            at.arrays[forces_label] = at.get_forces()&#xD;&#xA;            at.info[stress_label] = at.get_stress(voigt=True)&#xD;&#xA;&#xD;&#xA;#read()函数，这里，第一个参数是所读文件路径，第二个参数是切片slice&#xD;&#xA;IsolatedH = read(&#39;IsolatedAtoms/H/OUTCAR.tar.gz&#39;,&#39;:&#39;)&#xD;&#xA;IsolatedO = read(&#39;IsolatedAtoms/O/OUTCAR.tar.gz&#39;,&#39;:&#39;)&#xD;&#xA;IsolatedAtoms = IsolatedH + IsolatedO&#xD;&#xA;addlabel(configs=IsolatedAtoms,is_isolated=True)&#xD;&#xA;&#xD;&#xA;#这里的slice的意思是从第一个结构开始到最后一个结构，每100个结构取一个&#xD;&#xA;db = read(&#39;H2O/OUTCAR.tar.gz&#39;,&#39;::100&#39;)&#xD;&#xA;addlabel(configs=db)&#xD;&#xA;&#xD;&#xA;#将打过标签的数据集合并&#xD;&#xA;db = db + IsolatedAtoms&#xD;&#xA;write(&#39;trainset.xyz&#39;,db)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这里有趣的一点是，为什么对于单个结构的&lt;code&gt;OUTCAR&lt;/code&gt;，也要进行切片：&lt;code&gt;IsolatedH = read(&#39;IsolatedAtoms/H/OUTCAR.tar.gz&#39;,&#39;:&#39;)&lt;/code&gt;，而不是&lt;code&gt;IsolatedH = read(&#39;IsolatedAtoms/H/OUTCAR.tar.gz&#39;)&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>机器学习势MACE的输入文件</title>
      <link>http://localhost:1313/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/mace2/</link>
      <pubDate>Fri, 16 May 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/mace2/</guid>
      <description>&lt;h1 id=&#34;机器学习势mace的输入文件&#34;&gt;机器学习势MACE的输入文件&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;不同MACE版本的参数设置会有一定的调查，注意查看自己的MACE版本。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>均方位移（MSD）-OVITO</title>
      <link>http://localhost:1313/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/msd_ovito/</link>
      <pubDate>Tue, 13 May 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/msd_ovito/</guid>
      <description>&lt;h1 id=&#34;均方位移msd计算-by-ovito&#34;&gt;均方位移（MSD）计算 by OVITO&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&#xA;&lt;a href=&#34;https://docs.ovito.org/python/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;OVITO Python Reference — OVITO Python Reference 3.12.3 documentation&lt;/a&gt;&#xA; 是一个开源且功能强大的分子动力学后处理软件包。&lt;/p&gt;&#xA;&lt;p&gt;本文将介绍如何利用 OVITO python module 计算某类元素原子在一段轨迹内的均方位移。&lt;/p&gt;&#xA;&lt;p&gt;适用于无机非晶体，其他体系慎用。&lt;/p&gt;&#xA;&lt;p&gt;软件：OVITO、matplotlib、numpy&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ovito版&#34;&gt;OVITO版&lt;/h2&gt;&#xA;&lt;h3 id=&#34;代码展示&#34;&gt;代码展示&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ovito.io import import_file, export_file&#xD;&#xA;from ovito.modifiers import CalculateDisplacementsModifier&#xD;&#xA;from ovito.modifiers import SelectTypeModifier,InvertSelectionModifier,DeleteSelectedModifier,ExpressionSelectionModifier&#xD;&#xA;import numpy as np&#xD;&#xA;import matplotlib.pyplot as plt&#xD;&#xA;&#xD;&#xA;#万物起源 import_file ，导入一段要计算的轨迹&#xD;&#xA;pipeline = import_file(&amp;quot;1.dump&amp;quot;)&#xD;&#xA;&#xD;&#xA;#添加 SelectTypeModifier 修饰器&#xD;&#xA;#设置参数 property = &#39;Particle Type&#39; 指定选择的类型（这里我们指定的是原子类型）&#xD;&#xA;#设置参数 types = {4} 指定具体的原子类型，这里是这个轨迹中的 4 原子（这个值要根据自己的体系修改），这里用数字代表原子是因为我使用的lammps的输出风格没有记录原子的元素符号，如果你的轨迹里记录的是 元素符号 信息，比如说 VASP 输出的 XDATCAR，则需要用类似于 types = {&amp;quot;H&amp;quot;} 的写法&#xD;&#xA;pipeline.modifiers.append(SelectTypeModifier(property = &#39;Particle Type&#39;, types = {4}))&#xD;&#xA;&#xD;&#xA;#添加 InvertSelectionModifier 修饰器，进行原子反选，为剔除不需要计算的原子做准备&#xD;&#xA;pipeline.modifiers.append(InvertSelectionModifier())    &#xD;&#xA;&#xD;&#xA;#添加 DeleteSelectedModifier 修饰器，删除上一行代码反选的原子，留下需要计算的原子&#xD;&#xA;pipeline.modifiers.append(DeleteSelectedModifier(operate_on= {&#39;particles&#39;}))                    &#xD;&#xA;&#xD;&#xA;#添加 CalculateDisplacementsModifier 修饰器，指定计算 MSD 的参考结构，这里 reference_frame = 0 代表初始结构是参考结构&#xD;&#xA;reference_frame = 0&#xD;&#xA;pipeline.modifiers.append(CalculateDisplacementsModifier(reference_frame=0))    #a subclass of ovito.pipeline.ReferenceConfigurationModifier&#xD;&#xA;&#xD;&#xA;#自定义一个修饰器函数，用于将 per-particle displacement 转化为相应元素的均方位移&#xD;&#xA;#本文的 OVITO小知识 将简单介绍自定义修饰器是如何工作的&#xD;&#xA;def calculate_msd(frame, data):&#xD;&#xA;    &#xD;&#xA;&#x9;#用一个变量 displacement_magnitudes 记录 data.particles[&#39;Displacement Magnitude&#39;]，简化代码&#xD;&#xA;&#x9;displacement_magnitudes = data.particles[&#39;Displacement Magnitude&#39;]&#xD;&#xA;&#x9;#计算 MSD （将所有原子位移的平方加和然后求平均），OVITO 的数据可以直接和 numpy 交互，nice&#xD;&#xA;&#x9;msd = np.sum(displacement_magnitudes ** 2) / len(displacement_magnitudes)           &#xD;&#xA;&#x9;#把计算的 MSD 传递给 data (DataCollection类)&#xD;&#xA;&#x9;data.attributes[&amp;quot;MSD&amp;quot;] = msd &#xD;&#xA;    &#xD;&#xA;#添加自定义 calculate_msd 修饰器&#xD;&#xA;pipeline.modifiers.append(calculate_msd)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#计算 Pipeline, 得到time vs MSD的数据&#xD;&#xA;table = []     #用于存放数据，time vs MSD&#xD;&#xA;&#xD;&#xA;for frame,data in enumerate(pipeline.frames):&#xD;&#xA;&#x9;if frame &amp;gt;= reference_frame:&#xD;&#xA;&#x9;&#x9;#这里的 *10 一定要根据自己的计算调整，我的轨迹在lammps计算设置：时间步是0.5fs，每20步输出一帧，所以轨迹中每帧其实经历了10fs，所以乘以10&#xD;&#xA;&#x9;&#x9;#我们 time vs MSD 的x横坐标单位是fs，也可以是别的，自己调整&#xD;&#xA;&#x9;&#x9;time = (frame-reference_frame)*10                 &#xD;&#xA;&#x9;&#x9;table.append([time,data.attributes[&#39;MSD&#39;]])&#xD;&#xA;&#xD;&#xA;#.csv文件还是比较高级的，比纯txt好些，delimiter 指定间隔符为 &amp;quot;,&amp;quot; ,这样方便直接excel打开&#xD;&#xA;np.savetxt(&amp;quot;msd_data.csv&amp;quot;,table,delimiter=&amp;quot;,&amp;quot;)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;ovito小知识&#34;&gt;OVITO小知识&lt;/h2&gt;&#xA;&lt;p&gt;受限于Python基础和时间精力的限制，以下内容皆为我个人的有限理解，未能严格考究，仅供参考。&lt;/p&gt;</description>
    </item>
    <item>
      <title>稍微深入一些Python中的类（class）</title>
      <link>http://localhost:1313/%E4%BB%A3%E7%A0%81/class_in_python/</link>
      <pubDate>Tue, 13 May 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E4%BB%A3%E7%A0%81/class_in_python/</guid>
      <description>&lt;h1 id=&#34;稍微深入一些python中的类class&#34;&gt;稍微深入一些Python中的类（class）&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;**类（class）**在python代码中几乎无处不在，但在近日的学习中发现，我对它真是了解甚少，甚至基础结构都不能熟稔于心，故开此笔记认真学习。和我一起重新认识一下它吧。&lt;/p&gt;&#xA;&lt;h2 id=&#34;一个简单的类&#34;&gt;一个简单的类&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#code 1&#xD;&#xA;class Dog:&#xD;&#xA;    # 类属性&#xD;&#xA;    species = &amp;quot;Dog&amp;quot;&#xD;&#xA;    # 初始化方法&#xD;&#xA;    def __init__(self, name, age):&#xD;&#xA;        self.name = name&#xD;&#xA;        self.age = age&#xD;&#xA;    # 实例方法&#xD;&#xA;    def bark(self):&#xD;&#xA;        return print(&amp;quot;旺旺&amp;quot;)&#xD;&#xA;&#xD;&#xA;print(mydog.species)&#xD;&#xA;print(mydog.name,mydog.age)&#xD;&#xA;mydog.bark()&#xD;&#xA;&#xD;&#xA;#输出为：&#xD;&#xA;#Dog&#xD;&#xA;#doudou 2&#xD;&#xA;#旺旺&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;strong&gt;类&lt;/strong&gt;是一种对数据进行计算操作的蓝图，离不开&lt;strong&gt;属性&lt;/strong&gt;和&lt;strong&gt;方法&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;code 1中，我们定义了一个 Dog 类，并对它进行了实例化，生成了一个对象。&lt;/p&gt;&#xA;&lt;p&gt;这个类的结构，很简单。&lt;/p&gt;&#xA;&lt;p&gt;首先是放在第一部分的&lt;strong&gt;类属性&lt;/strong&gt;。&lt;strong&gt;类属性&lt;/strong&gt;是&lt;strong&gt;直接在类中定义变量&lt;/strong&gt;。所有通过这个类生成的对象都具有这些属性。&lt;/p&gt;&#xA;&lt;p&gt;然后是放在第二部分的诸多方法，其实就是一个个的函数。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def __init__(self, name, age):&#xD;&#xA;        self.name = name&#xD;&#xA;        self.age = age&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;_init_&lt;/code&gt;方法叫&lt;strong&gt;初始化方法&lt;/strong&gt;，是&lt;strong&gt;魔法方法&lt;/strong&gt;的一种。让实例初始化时就具有&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;age&lt;/code&gt;属性和相应的值。具体表现为&lt;code&gt;mydog = Dog(&amp;quot;doudou&amp;quot;,2)&lt;/code&gt;，这个类在初始化时就&lt;strong&gt;需要两个参数&lt;/strong&gt;才能转变为实例。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;python中所有的实例方法，包括&lt;code&gt;__init__&lt;/code&gt;方法，第一个参数都必须是&lt;code&gt;self&lt;/code&gt;，用于区别&lt;strong&gt;普通函数&lt;/strong&gt;和&lt;strong&gt;方法&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;默认值&lt;/strong&gt;，在定义方法的时候，可以传入默认值，这可以保证在不传入参数时，也能生成一个默认实例。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def __init__(self, name=&amp;quot;小卡拉米&amp;quot;, age=5):&#xD;&#xA;        self.name = name&#xD;&#xA;        self.age = age&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这样的&lt;code&gt;__init__&lt;/code&gt;方法就保证了，即使狗主人忘记了填写信息，&lt;code&gt;mydog = Dog()&lt;/code&gt;也能正常工作，但默认的狗狗是&lt;strong&gt;小卡拉米&lt;/strong&gt;，还是应该记得为自己的狗狗正确填写信息呦。（对于其他实例方法也适用）&lt;/p&gt;</description>
    </item>
    <item>
      <title>径向分布函数（RDF）-OVITO</title>
      <link>http://localhost:1313/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/rdf_ovito/</link>
      <pubDate>Mon, 12 May 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/rdf_ovito/</guid>
      <description>&lt;h1 id=&#34;径向分布函数rdf计算-by-ovito&#34;&gt;径向分布函数（RDF）计算 by OVITO&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&#xA;&lt;a href=&#34;https://docs.ovito.org/python/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;OVITO Python Reference — OVITO Python Reference 3.12.3 documentation&lt;/a&gt;&#xA; 是一个开源且功能强大的分子动力学后处理软件包。&lt;/p&gt;&#xA;&lt;p&gt;本文将介绍如何利用 OVITO python module 计算单个结构以及一段轨迹（多个结构）内的径向分布函数。&lt;/p&gt;&#xA;&lt;p&gt;适用于无机非晶体，其他体系慎用。&lt;/p&gt;&#xA;&lt;p&gt;软件：OVITO、matplotlib、numpy&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-partial-rdfs-of-a-single-crystal-structure&#34;&gt;The partial RDFs of a single crystal structure&lt;/h2&gt;&#xA;&lt;h3 id=&#34;代码展示&#34;&gt;代码展示&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#这段代码用于计算 RDF by OVITO&#xA;from ovito.io import import_file&#xA;from ovito.modifiers import CoordinationAnalysisModifier&#xA;import numpy as np&#xA;&#xA;#导入一个氧化锆（ZrO2）的cif文件，所有OVITO支持的输入文件格式都可以（确保这个.py文件的路径下有这样一个cif文件，也可以稍微修改指定结构路径）&#xA;pipeline = import_file(&amp;quot;ZrO.cif&amp;quot;)&#xA;&#xA;#施加一个名叫 CoordinationAnalysisModifier 的修饰器，cutoff用于控制截断半径，number_of_bins用于控制网格细分度（大小100-1000内都可以试试）&#xA;pipeline.modifiers.append(CoordinationAnalysisModifier(cutoff = 5.0, number_of_bins = 500,partial=True))&#xA;&#xA;#进行计算&#xA;rdf_table = pipeline.compute().tables[&#39;coordination-rdf&#39;]&#xA;&#xA;#得到用于画图的横纵坐标，默认第一列是x轴数据，其余列是y轴数据&#xA;total_rdf = rdf_table.xy()&#xA;&#xA;#记录total_rdf中y轴数据对应是什么类型的pair-wise&#xA;#这个例子中，输出为：&#xA;#g(r) for pair-wise type combination O-O:&#xA;#g(r) for pair-wise type combination O-Zr:&#xA;#g(r) for pair-wise type combination Zr-Zr:&#xA;#说明total_rdf是一个四列的数据，第一列是x轴坐标（其实是bin），第二列就是不同pair-wise的RDF数据，依次为 O-O,O-Zr,Zr-Zr&#xA;rdf_names = rdf_table.y.component_names&#xA;for component, name in enumerate(rdf_names):&#xA;    print(&amp;quot;g(r) for pair-wise type combination %s:&amp;quot; % name)&#xA;    &#xA;#将total_rdf保存为txt文件，用于后续画图&#xA;np.savetxt(&amp;quot;total_rdf.txt&amp;quot;, total_rdf)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#这段代码用于绘图&#xA;import numpy as np&#xA;import matplotlib.pyplot as plt&#xA;&#xA;rdf_table = np.loadtxt(&#39;total_rdf.txt&#39;)&#xA;&#xA;#g(r) for pair-wise type combination O-O:&#xA;#g(r) for pair-wise type combination O-Zr:&#xA;#g(r) for pair-wise type combination Zr-Zr:&#xA;&#xA;#这里取的是 total_rdf.txt 中的第一列（对应[:,0]）和第三列（对应[:,2]），所以绘制的是 Zr-O pair-wise的partial RDF&#xA;plt.plot(rdf_table[:,0], rdf_table[:,2])&#xA;&#xA;#matplotlib的常规设置，问问万能的小迪老师吧&#xA;title_font = {&#39;fontsize&#39;: 24, &#39;fontfamily&#39;: &#39;Times New Roman&#39;}&#xA;xlabel_font = {&#39;fontsize&#39;: 22, &#39;fontfamily&#39;: &#39;Times New Roman&#39;}&#xA;ylabel_font = {&#39;fontsize&#39;: 22, &#39;fontfamily&#39;: &#39;Times New Roman&#39;}&#xA;&#xA;plt.title(&amp;quot;RDF Zr-O&amp;quot;, fontdict=title_font,pad=8)&#xA;plt.xlabel(xlabel=&#39;distance r&#39;,fontdict=xlabel_font,loc=&#39;center&#39;,labelpad=8)&#xA;plt.ylabel(ylabel=&#39;g(r)&#39;,fontdict=ylabel_font,loc=&#39;center&#39;,labelpad=8)&#xA;plt.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16, direction=&#39;in&#39;)&#xA;&#xA;ax = plt.subplot()&#xA;&#xA;#因为只有一个静态结构，pair-wise的某些峰很高，所以这里的y轴坐标上限设置大一些，为200，可灵活改变&#xA;#x轴设置为6，稍大于截断半径cutoff即可，因为本身也只在截断半径以内统计&#xA;ax.set_ylim(0,200)&#xA;plt.xlim(0,6)&#xA;&#xA;fig = plt.gcf()&#xA;&#xA;fig.set_size_inches(1200/100, 800/100)&#xA;plt.savefig(&#39;output.png&#39;, dpi=100)&#xA;&#xA;plt.show()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;结果展示&#34;&gt;结果展示&lt;/h3&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/output.png&#34;/&gt;&#xA;&lt;h2 id=&#34;the-partial-rdfs-of-trajectories&#34;&gt;The partial RDFs of trajectories&lt;/h2&gt;&#xA;&lt;h3 id=&#34;代码展示-1&#34;&gt;代码展示&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#这段代码用于计算一定时间内（一段轨迹）的平均 RDFs&#xA;from ovito.io import import_file&#xA;from ovito.modifiers import CoordinationAnalysisModifier,TimeAveragingModifier&#xA;import numpy as np&#xA;&#xA;#读入轨迹文件，这里是利用 VASP 进行 AIMD 后得到的 XDATCAR 文件&#xA;pipeline = import_file(&amp;quot;XDATCAR&amp;quot;)&#xA;&#xA;#打印轨迹中的结构数&#xA;print(&amp;quot;Number of MD frames:&amp;quot;, pipeline.num_frames)&#xA;&#xA;#添加修饰器，与单个晶体结构相比，多了 TimeAveragingModifier 修饰器&#xA;pipeline.modifiers.append(CoordinationAnalysisModifier(cutoff = 5.0, number_of_bins = 500,partial=True))&#xA;pipeline.modifiers.append(TimeAveragingModifier(operate_on=&#39;table:coordination-rdf&#39;))&#xA;&#xA;#计算 RDFs 数据&#xA;total_rdf = pipeline.compute().tables[&#39;coordination-rdf[average]&#39;].xy()&#xA;&#xA;#记录pair-wise类型&#xA;rdf_names = pipeline.compute().tables[&#39;coordination-rdf[average]&#39;].y.component_names&#xA;for name in rdf_names:&#xA;    print(&amp;quot;g(r) for pair-wise type combination %s:&amp;quot; % name)&#xA;&#xA;#输出数据，用于后续绘图，不再重复&#xA;np.savetxt(&#39;rdf.txt&#39;, total_rdf, delimiter=&#39;\t&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;ovito小知识&#34;&gt;OVITO小知识&lt;/h2&gt;&#xA;&lt;p&gt;受限于Python基础和时间精力的限制，以下内容皆为我个人的有限理解，未能严格考究，仅供参考。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/search/</guid>
      <description></description>
    </item>
    <item>
      <title>Archives</title>
      <link>http://localhost:1313/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/archives/</guid>
      <description></description>
    </item>
    <item>
      <title>枭枭不爱咕咕叫</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/about/</guid>
      <description>&lt;p&gt;保藏秘密、分享知识，人间美德。谦谦君子，温润如是。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
