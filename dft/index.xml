<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DFTs on BOGHTW</title><link>https://liubaoshuai1402.github.io/dft/</link><description>Recent content in DFTs on BOGHTW</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Mon, 08 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://liubaoshuai1402.github.io/dft/index.xml" rel="self" type="application/rss+xml"/><item><title>频率计算</title><link>https://liubaoshuai1402.github.io/dft/frequency/</link><pubDate>Mon, 08 Sep 2025 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/frequency/</guid><description>&lt;h1 id="零点能计算"&gt;零点能计算&lt;/h1&gt;
&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;我对零点能的理解非常肤浅，以下仅是从网上捕风捉影而来，用于个人记录。&lt;/p&gt;
&lt;p&gt;在计算自由能时，看到一些文献的做法是：DFT总能+零点能+熵。&lt;/p&gt;
&lt;p&gt;零点能是0K下，体系的振动能，可以通过声子频率计算而来。&lt;/p&gt;
&lt;p&gt;声子计算可能由phonopy完成，但是也有通过单vasp计算的。&lt;/p&gt;
&lt;p&gt;这里记录一下，只用vasp计算gamma点声子频率的步骤，用于零点能的粗略计算。&lt;/p&gt;
&lt;h3 id="incar"&gt;INCAR&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ISMEAR = 0
IBRION = 5 
NFREE = 2 
POTIM = 0.02
NSW = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;频率计算的关键参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IBRION = 5&lt;/code&gt;启用有限位移法计算声子模。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NFREE = 2&lt;/code&gt; 设置原子振动的自由度。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;POTIM = 0.02&lt;/code&gt; 设置振动的幅度。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSW = 1&lt;/code&gt; 离子步为1&lt;/p&gt;</description></item><item><title>DOS</title><link>https://liubaoshuai1402.github.io/dft/dos/</link><pubDate>Wed, 03 Sep 2025 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/dos/</guid><description>&lt;h1 id="电子态密度dos计算"&gt;电子态密度（DOS）计算&lt;/h1&gt;
&lt;h3 id="incar"&gt;INCAR&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Start Parameters for this run
 ISTART = 0
 ICHARG = 2
 PREC = Accurate
 ALGO = Normal
 ISMEAR = -5
 LCHARG = .TRUE.
 LREAL = .FALSE.
 LELF = .TRUE.
 ISYM = 0
 GGA = PS
 LORBIT = 12
 NSW = 0
 NBANDS = 520
 NEDOS = 1000

Electronic minimisation
 ENCUT = 480 
 NELM = 100
 NELMIN = 4
 EDIFF = 1E-6
 ISPIN = 1 

Ionic relaxation 
 IBRION = -1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="dos的质量"&gt;DOS的质量&lt;/h3&gt;
&lt;h4 id="k点"&gt;k点&lt;/h4&gt;
&lt;p&gt;k点太稀疏，会导致尖锐的点出现。&lt;/p&gt;</description></item><item><title>超晶格材料原子尺度建模</title><link>https://liubaoshuai1402.github.io/dft/%E6%8C%87%E5%AE%9Aposcar%E5%8E%9F%E5%AD%90%E7%9A%84%E8%87%AA%E7%94%B1%E5%BA%A6/</link><pubDate>Fri, 15 Aug 2025 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/%E6%8C%87%E5%AE%9Aposcar%E5%8E%9F%E5%AD%90%E7%9A%84%E8%87%AA%E7%94%B1%E5%BA%A6/</guid><description>&lt;p&gt;根据原子的z轴坐标，指定哪些是自由的，哪些是受限制的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ase.constraints import FixAtoms
from ase.io import write, read

fixed_indices = [] # 要固定的原子索引
atoms = read('POSCAR_BiTe1_Pt')
for i in range(len(atoms)):
 position_z = atoms[i].position[2]
 if 40 &amp;gt; position_z &amp;gt; 15.5:
 indice = atoms[i].index
 fixed_indices.append(indice)
 if 3 &amp;lt; position_z &amp;lt; 7:
 indice = atoms[i].index
 fixed_indices.append(indice)

atoms.set_constraint(FixAtoms(indices=fixed_indices))
write('POSCAR_BiTe1_Pt_sel', atoms, format='vasp')




&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>晶体表面建模</title><link>https://liubaoshuai1402.github.io/dft/themodelingofsurface/</link><pubDate>Thu, 14 Aug 2025 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/themodelingofsurface/</guid><description>&lt;h1 id="晶体表面建模"&gt;晶体表面建模&lt;/h1&gt;
&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;晶体表面建模中有很多细节。&lt;/p&gt;
&lt;p&gt;比如说，要建模(111)面，首先要给出切表面时所采用的晶胞，是primitive cell ？还是conventional cell ？还是自己定义的晶胞。&lt;/p&gt;
&lt;p&gt;以四方氧化锆为例，
&lt;a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.58.8050" target="_blank" rel="noopener noreferrer" &gt;在这篇文献中&lt;/a&gt;
，计算得到的最稳定表面是(111)，作者就明确指出，他切表面时采用的是重构后的类CaF&lt;sub&gt;2&lt;/sub&gt;型的晶胞，而非原胞。&lt;/p&gt;
&lt;p&gt;实际上，对于四方氧化锆，这种晶胞的(111)面与原胞的(101)面是同一个面，这也就是为什么有很多文献说，四方氧化锆的最稳定表面是(101)面。&lt;/p&gt;
&lt;p&gt;虽然不指出具体的切割的晶胞时，人们可能会默认为是用的原胞，但我个人认为还是明确指出为好，防止引起不必要的误解。&lt;/p&gt;
&lt;p&gt;其次，除了密勒指数，UV矢量也很重要，即面内的两个坐标轴，他觉得&lt;/p&gt;</description></item><item><title>超晶格材料原子尺度建模</title><link>https://liubaoshuai1402.github.io/dft/themodelingofsuperlattice/</link><pubDate>Tue, 05 Aug 2025 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/themodelingofsuperlattice/</guid><description>&lt;h1 id="超晶格材料原子尺度建模"&gt;超晶格材料原子尺度建模&lt;/h1&gt;
&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;虽然异质结的建模攻略很多，但大都以Material Studio为主，且对象是表界面。对于周期性的超晶格材料的建模，特别是异质结情况，参考较少，这里我分享一下个人的经验。采用ASE进行建模。&lt;/p&gt;
&lt;p&gt;异质结的两种材料接触时，哪两个面间的接触，是需要确定的，比如说，根据实验确定，又或者无实验时，根据晶格匹配度确定，尽量保证失配度较低。&lt;/p&gt;
&lt;p&gt;这里，假设已经确定了，两个材料的晶胞要沿着z轴堆叠。&lt;/p&gt;
&lt;p&gt;整体思路：&lt;/p&gt;
&lt;p&gt;1.确定好要合并的两个晶格的具体结构（用translate平移，surface切面，这个顺序好像也能反过来）&lt;/p&gt;
&lt;p&gt;2.合并晶格（stack用起来还是蛮需要经验的）&lt;/p&gt;
&lt;h3 id="如何切一个晶面并生成周期性结构"&gt;如何切一个晶面，并生成周期性结构&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ase.build import surface,stack,make_supercell
from ase.io import read,write
from ase.io.vasp import write_vasp

BiTe = read('POSCAR_BiTe')
BiTe = make_supercell(BiTe,P=[[2,0,0],[0,1,0],[0,0,1]])
BiTe1 = BiTe.copy()
BiTe2 = BiTe.copy()
BiTe2.translate([0,0,-2.05985])
BiTe3 = BiTe.copy()
BiTe3.translate([0,0,-3.79553])

BiTe1 = surface(BiTe1,indices=(0,0,1),layers=1,periodic=True)
BiTe2 = surface(BiTe2,indices=(0,0,1),layers=1,periodic=True)
BiTe3 = surface(BiTe3,indices=(0,0,1),layers=1,periodic=True)
write_vasp('POSCAR_BiTe1',BiTe1,direct=True,sort=True)
write_vasp('POSCAR_BiTe2',BiTe2,direct=True,sort=True)
write_vasp('POSCAR_BiTe3',BiTe3,direct=True,sort=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ase的surface函数可以很简单的实现，这里不赘述了。&lt;/p&gt;
&lt;p&gt;此外，关于如何确定一个合适的新晶格的大小，也有很多视频讲解，不再赘述。&lt;/p&gt;
&lt;h3 id="改变晶体结构的原子层顺序"&gt;改变晶体结构的原子层顺序&lt;/h3&gt;
&lt;p&gt;即便是只有一种原子的晶体，其沿某个面的堆垛的时候，可能有不同的层。比如FCC晶体沿001面的堆垛方式就是&amp;mdash;ABAB&amp;mdash;，显然与别的物质形成异质结时，会面临一个问题，即是A面还是B面与别的物质接触。&lt;/p&gt;
&lt;p&gt;我们建模时，需要把A面或B面调整出来。这需要对原子进行整体位移&lt;/p&gt;
&lt;p&gt;此外，异质结平面内的原子对齐（比如说xy面），也需要对原子进行整体位移。&lt;/p&gt;
&lt;p&gt;而ASE实现原子整体位移非常简单，只需要用&lt;code&gt;atoms&lt;/code&gt;类的&lt;code&gt;translate&lt;/code&gt;方法即可，注意使用绝对坐标。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ase.build import surface,stack,make_supercell
from ase.io import read,write
from ase.io.vasp import write_vasp

BiTe = read('POSCAR_BiTe')
BiTe = make_supercell(BiTe,P=[[2,0,0],[0,1,0],[0,0,1]])
BiTe1 = BiTe.copy()
BiTe2 = BiTe.copy()
BiTe2.translate([0,0,-2.05985])
BiTe3 = BiTe.copy()
BiTe3.translate([0,0,-3.79553])
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="ase实现超晶格材料建模"&gt;ASE实现超晶格材料建模&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ase.build import surface,stack,make_supercell
from ase.io import read,write
from ase.io.vasp import write_vasp

BiTe1 = read('POSCAR_BiTe1')
BiTe2 = read('POSCAR_BiTe2')
BiTe3 = read('POSCAR_BiTe3')

Ag = make_supercell(read('POSCAR_Ag'),P=[[2,0,0],[0,2,0],[0,0,3]])
BiTe1_Ag = stack(Ag,BiTe1,axis=2,fix=0.5)
BiTe2_Ag = stack(Ag,BiTe2,axis=2,fix=0.5)
BiTe3_Ag = stack(Ag,BiTe3,axis=2,fix=0.5)

write('POSCAR_BiTe1_Ag',BiTe1_Ag,format='vasp')
write('POSCAR_BiTe2_Ag',BiTe2_Ag,format='vasp')
write('POSCAR_BiTe3_Ag',BiTe3_Ag,format='vasp')
&lt;/code&gt;&lt;/pre&gt;
&lt;img src="https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/spl1.png"/&gt;
&lt;h5 id="关于ase中stack函数的原理"&gt;关于ase中stack函数的原理。&lt;/h5&gt;
&lt;p&gt;将两个周期性的晶胞合并成一个周期性的晶胞，有一个必须要面对的问题，那就是接触面将不再有周期性。&lt;/p&gt;</description></item><item><title>随机取代晶体结构中的元素</title><link>https://liubaoshuai1402.github.io/dft/%E9%9A%8F%E6%9C%BA%E5%8F%96%E4%BB%A3%E5%85%83%E7%B4%A0/</link><pubDate>Wed, 16 Jul 2025 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/%E9%9A%8F%E6%9C%BA%E5%8F%96%E4%BB%A3%E5%85%83%E7%B4%A0/</guid><description>&lt;h1 id="从一个实例中学习python中的排列组合的实现"&gt;从一个实例中学习python中的排列组合的实现&lt;/h1&gt;
&lt;h2 id="zro2中掺杂y元素"&gt;ZrO2中掺杂Y元素&lt;/h2&gt;
&lt;p&gt;一个96原子的晶胞，去掉一个氧空位，再取代两个Zr原子，就是一个通用的YSZ模型（95 原子）。&lt;/p&gt;
&lt;p&gt;但是Y与Vo的相对位置，是一个麻烦。&lt;/p&gt;
&lt;p&gt;Y的掺杂会不会带来晶胞大小的变化。我这里的处理是根据以往的文献，确定一个可能的构型。&lt;/p&gt;
&lt;p&gt;然后考虑一下掺杂对晶胞尺寸带来的影响，然后就定了，Y再换其他位置也认为不会再影响了。（因为比起相对位置，肯定有无Y原子才是影响的大头）&lt;/p&gt;
&lt;p&gt;确定了晶胞尺寸，结构优化后，再把Y换成Zr。然后随机取代，最终确定$C_{32}^2$个结构，计算单点能，用于机器学习势学习。&lt;/p&gt;
&lt;h3 id="代码"&gt;代码&lt;/h3&gt;
&lt;p&gt;由大G老师支持。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ase.io import read
from ase.io.vasp import write_vasp
from itertools import combinations
import os

at = read('POSCAR')


# 找到所有 Zr 原子的索引
zr_indices = [i for i, atom in enumerate(at) if atom.symbol == 'Zr']
print(f&amp;quot;找到 {len(zr_indices)} 个 Zr 原子&amp;quot;)

# 创建保存目录
os.makedirs(&amp;quot;ZrO_Y2_structures&amp;quot;, exist_ok=True)

# 枚举所有 Zr 的两两组合，逐个替换为 Y
for count, (i, j) in enumerate(combinations(zr_indices, 2)):
 new_at = at.copy()
 new_at[i].symbol = 'Y'
 new_at[j].symbol = 'Y'

 # 写入文件 
 subdir = f&amp;quot;ZrO_Y2_structures/{count}&amp;quot;
 os.makedirs(subdir, exist_ok=True)
 filename = os.path.join(subdir, &amp;quot;POSCAR&amp;quot;)
 write_vasp(filename, new_at,direct=True,sort=True)
 print(f&amp;quot;写入结构：{filename}&amp;quot;)

print(f&amp;quot;共生成 {count + 1} 个结构。&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;combations&lt;/code&gt;类是python中实现组合的高效方式。参数为一个列表，一个长度。返回一个包含若干元组的列表。&lt;/p&gt;</description></item><item><title>COHP</title><link>https://liubaoshuai1402.github.io/dft/cohp/</link><pubDate>Sat, 28 Jun 2025 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/cohp/</guid><description>&lt;h1 id="cohp"&gt;COHP&lt;/h1&gt;
&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;h3 id="vasp文件的准备"&gt;VASP文件的准备&lt;/h3&gt;
&lt;p&gt;LOBSTER要求ISYM=0或-1。其他参数没有特殊要求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构优化&lt;/p&gt;
&lt;p&gt;略过&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;静态自洽&lt;/p&gt;
&lt;p&gt;以较为简单的K点设置计算波函数、电荷密度。&lt;/p&gt;
&lt;p&gt;用于得到WAVECAR、CHGCAR&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#关键参数
ISTART = 0 
ICHARG = 2
NSW = 0
NBANDS = 500	#这个值要大，多试试
NEDOS = 1000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后续的非静态自洽的NBANDS和NEDOS尽量和这里保持一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非静态自洽&lt;/p&gt;
&lt;p&gt;不再更新波函数和电荷密度，进行一次单次的求解。&lt;/p&gt;
&lt;p&gt;这里可以设置更密的K点来求态密度，也可以设置特殊路径的K点来求能带结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#关键参数
ISTART = 1 # 使用前一轮的波函数
ICHARG = 11 # 使用前一轮的电荷密度，不再更新
NSW = 0
LORBIT = 12
NBANDS = 500	#这个值要大，多试试
NEDOS = 1000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特别说一下LORBIT参数，这个参数是后处理参数，和VASP的电子计算无关。&lt;/p&gt;
&lt;p&gt;指示VASP生成：DOSCAR and lm-decomposed PROCAR + phase factors (not recommended)&lt;/p&gt;
&lt;p&gt;所以只需要最后非静态自洽的时候设置即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，如果对精度不高，或者不考虑成本，我看也有人直接用静态自洽的结果（这里直接设置比较高的K点密度）进行LOBSTER。&lt;/p&gt;
&lt;p&gt;如果用的&lt;code&gt;ISMEAR = 0&lt;/code&gt;，后续要在lobsterin文件中指出。&lt;/p&gt;</description></item><item><title>用VASP进行第一性原理分子动力学（AIMD）</title><link>https://liubaoshuai1402.github.io/dft/aimd/</link><pubDate>Sat, 28 Jun 2025 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/aimd/</guid><description>&lt;h1 id="aimd"&gt;AIMD&lt;/h1&gt;
&lt;h3 id="nvt系综"&gt;nvt系综&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ISTART = 0
ENCUT = 480
PREC = Normal
ALGO = Fast
LREAL = Auto
LWAVE = .F. 
LCHARG = .F.
GGA = PS
ISMEAR = 0
SIGMA = 0.05
ISPIN = 1

#electronstep
NELM = 200
NELMIN = 4
EDIFF = 1E-4

#AIMD
IBRION = 0 
MDALGO = 2 
ISIF = 2 
TEBEG = 1500 
NSW = 5000 
POTIM = 0.5 
SMASS = 0.5

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IBRION&lt;/code&gt;是控制离子步优化算法的参数，进行分子动力学是设置为0。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MDALGO&lt;/code&gt;这个参数控制恒温器选项。&lt;/p&gt;</description></item><item><title/><link>https://liubaoshuai1402.github.io/dft/yambo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/yambo/</guid><description>&lt;h1 id="yambo"&gt;yambo&lt;/h1&gt;
&lt;h2 id="background-theory"&gt;Background theory&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://wiki.yambo-code.eu/wiki/index.php?title=Single_particle_Green%27s_function" target="_blank" rel="noopener noreferrer" &gt;Single particle Green&amp;rsquo;s function&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title/><link>https://liubaoshuai1402.github.io/dft/%E6%B0%A2%E5%92%8C%E6%B0%B4%E5%BB%BA%E6%A8%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://liubaoshuai1402.github.io/dft/%E6%B0%A2%E5%92%8C%E6%B0%B4%E5%BB%BA%E6%A8%A1/</guid><description>&lt;h1 id="氢水建模"&gt;氢水建模&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;import numpy as np
from ase.build import molecule
from ase import Atoms
from ase.io import read
from ase.io.vasp import write_vasp

def rotation_matrix_from_euler(alpha, beta, gamma, degrees=True):
 &amp;quot;&amp;quot;&amp;quot;
 生成绕 x, y, z 轴依次旋转 alpha, beta, gamma 的旋转矩阵。
 Rotation applied as: first Rx(alpha), then Ry(beta), then Rz(gamma).
 返回一个 3x3 的 numpy 矩阵 R，使得 r' = R @ r (列向量)。
 &amp;quot;&amp;quot;&amp;quot;
 if degrees:
 a = np.deg2rad(alpha)
 b = np.deg2rad(beta)
 g = np.deg2rad(gamma)
 else:
 a, b, g = alpha, beta, gamma

 Rx = np.array([[1, 0, 0],
 [0, np.cos(a), -np.sin(a)],
 [0, np.sin(a), np.cos(a)]])
 Ry = np.array([[ np.cos(b), 0, np.sin(b)],
 [0, 1, 0],
 [-np.sin(b), 0, np.cos(b)]])
 Rz = np.array([[np.cos(g), -np.sin(g), 0],
 [np.sin(g), np.cos(g), 0],
 [0, 0, 1]])
 # 总旋转：先 Rx 然后 Ry 然后 Rz -&amp;gt; R = Rz @ Ry @ Rx
 R = Rz @ Ry @ Rx
 return R

def add_water(atoms, target_pos, orientation=(0, 0, 0),
 anchor='COM', use_fractional=True, cell=None):

 if cell is None:
 cell = atoms.get_cell()

 # 计算目标笛卡尔坐标
 if use_fractional:
 if cell is None or np.linalg.norm(cell) == 0:
 raise ValueError(&amp;quot;没有可用的 cell 来把分数坐标转换为笛卡尔。传入 cell 或将 use_fractional=False。&amp;quot;)
 target_cart = np.dot(np.asarray(target_pos), cell) # frac @ cell
 else:
 target_cart = np.asarray(target_pos, dtype=float)

 # 生成水分子
 water = molecule(&amp;quot;H2O&amp;quot;) # ASE 内置
 # 选择锚点并将其移动到原点
 if anchor.upper() == 'COM':
 ref = water.get_center_of_mass()
 elif anchor.upper() == 'O':
 syms = water.get_chemical_symbols()
 try:
 o_idx = syms.index('O')
 ref = water.positions[o_idx].copy()
 except ValueError:
 # 退回到 COM
 ref = water.get_center_of_mass()
 else:
 raise ValueError(&amp;quot;anchor 必须是 'COM' 或 'O'。&amp;quot;)

 # 把参考点移动到原点
 water.translate(-ref)

 # 应用旋转（关于原点）
 R = rotation_matrix_from_euler(*orientation, degrees=True)
 # positions 为 (N,3)，对每个原子应用 R: pos' = (R @ pos.T).T
 water.positions = (R @ water.positions.T).T

 # 平移到目标笛卡尔位置
 water.translate(target_cart)

 # 合并并返回
 new_atoms = atoms + water
 return new_atoms

from ase.io import read
prim = read('../../CONTCAR')
new_atoms = add_water(prim, target_pos=(0.5, 0.5, 0.75), orientation=(10, 20, 90))
from ase.io import write
write_vasp(&amp;quot;0Vo/ori2/POSCAR&amp;quot;, new_atoms, direct=True,sort=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;import numpy as np
from ase.build import molecule
from ase import Atoms
from ase.io import write, read
from ase.io.vasp import write_vasp

def rotation_matrix_from_euler(alpha, beta, gamma, degrees=True):
 &amp;quot;&amp;quot;&amp;quot;生成绕 x, y, z 轴依次旋转的旋转矩阵。&amp;quot;&amp;quot;&amp;quot;
 if degrees:
 a = np.deg2rad(alpha)
 b = np.deg2rad(beta)
 g = np.deg2rad(gamma)
 else:
 a, b, g = alpha, beta, gamma

 Rx = np.array([[1, 0, 0],
 [0, np.cos(a), -np.sin(a)],
 [0, np.sin(a), np.cos(a)]])
 Ry = np.array([[ np.cos(b), 0, np.sin(b)],
 [0, 1, 0],
 [-np.sin(b), 0, np.cos(b)]])
 Rz = np.array([[np.cos(g), -np.sin(g), 0],
 [np.sin(g), np.cos(g), 0],
 [0, 0, 1]])
 return Rz @ Ry @ Rx


def add_h2(atoms, target_pos, orientation=(0, 0, 0),
 anchor='COM', use_fractional=True, cell=None):
 &amp;quot;&amp;quot;&amp;quot;
 在 atoms 中添加一分子 H2。

 参数:
 atoms : ASE Atoms 对象
 target_pos : 目标位置。如果 use_fractional=True，传入分数坐标 (fx,fy,fz)，否则笛卡尔坐标 (Å)。
 orientation : (alpha, beta, gamma)，绕 x,y,z 轴的欧拉角（度）。
 anchor : 'COM' 或 'H1'。决定氢分子哪个点对齐到 target_pos。
 'COM' -&amp;gt; 质心对齐； 'H1' -&amp;gt; 把第一个氢原子对齐到目标。
 use_fractional: 是否把 target_pos 当作分数坐标，默认 True。
 cell : 可选晶胞。如果 None，则用 atoms.get_cell()。

 返回:
 new_atoms : 含有氢分子的 ASE Atoms 对象
 &amp;quot;&amp;quot;&amp;quot;
 if cell is None:
 cell = atoms.get_cell()

 # 计算目标笛卡尔坐标
 if use_fractional:
 target_cart = np.dot(np.asarray(target_pos), cell) # frac -&amp;gt; cart
 else:
 target_cart = np.asarray(target_pos, dtype=float)

 # 生成氢分子
 h2 = molecule(&amp;quot;H2&amp;quot;)

 # 锚点
 if anchor.upper() == 'COM':
 ref = h2.get_center_of_mass()
 elif anchor.upper() == 'H1':
 ref = h2.positions[0].copy()
 else:
 raise ValueError(&amp;quot;anchor 必须是 'COM' 或 'H1'。&amp;quot;)

 # 移动锚点到原点
 h2.translate(-ref)

 # 旋转
 R = rotation_matrix_from_euler(*orientation, degrees=True)
 h2.positions = (R @ h2.positions.T).T

 # 平移到目标
 h2.translate(target_cart)

 # 合并
 new_atoms = atoms + h2
 return new_atoms


from ase.io import read
prim = read('../../CONTCAR')
new_atoms = add_h2(prim, target_pos=(0.5, 0.5, 0.25), orientation=(45, 45, 0))
from ase.io import write
write_vasp(&amp;quot;ori2/POSCAR&amp;quot;, new_atoms, direct=True,sort=True)
&lt;/code&gt;&lt;/pre&gt;</description></item></channel></rss>