<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BOGHTW</title>
    <link>https://liubaoshuai1402.github.io/</link>
    <description>Recent content on BOGHTW</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 16 Jul 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://liubaoshuai1402.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>超晶格材料原子尺度建模</title>
      <link>https://liubaoshuai1402.github.io/dft/themodelingofsuperlattice/</link>
      <pubDate>Wed, 16 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/dft/themodelingofsuperlattice/</guid>
      <description>&lt;h1 id=&#34;超晶格材料原子尺度建模&#34;&gt;超晶格材料原子尺度建模&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;虽然异质结的建模攻略很多，但大都以Material Studio为主，且对象是表界面。对于周期性的超晶格材料的建模，特别是异质结情况，参考较少，这里我分享一下个人的经验。采用ASE进行建模。&lt;/p&gt;&#xA;&lt;p&gt;异质结的两种材料接触时，哪两个面间的接触，是需要确定的，比如说，根据实验确定，又或者无实验时，根据晶格匹配度确定，尽量保证失配度较低。&lt;/p&gt;&#xA;&lt;p&gt;这里，假设已经确定了，两个材料的晶胞要沿着z轴堆叠。&lt;/p&gt;&#xA;&lt;p&gt;整体思路：&lt;/p&gt;&#xA;&lt;p&gt;1.确定好要合并的两个晶格的具体结构（用translate平移，surface切面，这个顺序好像也能反过来）&lt;/p&gt;&#xA;&lt;p&gt;2.合并晶格（stack用起来还是蛮需要经验的）&lt;/p&gt;&#xA;&lt;h3 id=&#34;如何切一个晶面并生成周期性结构&#34;&gt;如何切一个晶面，并生成周期性结构&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ase.build import surface,stack,make_supercell&#xD;&#xA;from ase.io import read,write&#xD;&#xA;from ase.io.vasp import write_vasp&#xD;&#xA;&#xD;&#xA;BiTe = read(&#39;POSCAR_BiTe&#39;)&#xD;&#xA;BiTe = make_supercell(BiTe,P=[[2,0,0],[0,1,0],[0,0,1]])&#xD;&#xA;BiTe1 = BiTe.copy()&#xD;&#xA;BiTe2 = BiTe.copy()&#xD;&#xA;BiTe2.translate([0,0,-2.05985])&#xD;&#xA;BiTe3 = BiTe.copy()&#xD;&#xA;BiTe3.translate([0,0,-3.79553])&#xD;&#xA;&#xD;&#xA;BiTe1 = surface(BiTe1,indices=(0,0,1),layers=1,periodic=True)&#xD;&#xA;BiTe2 = surface(BiTe2,indices=(0,0,1),layers=1,periodic=True)&#xD;&#xA;BiTe3 = surface(BiTe3,indices=(0,0,1),layers=1,periodic=True)&#xD;&#xA;write_vasp(&#39;POSCAR_BiTe1&#39;,BiTe1,direct=True,sort=True)&#xD;&#xA;write_vasp(&#39;POSCAR_BiTe2&#39;,BiTe2,direct=True,sort=True)&#xD;&#xA;write_vasp(&#39;POSCAR_BiTe3&#39;,BiTe3,direct=True,sort=True)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;ase的surface函数可以很简单的实现，这里不赘述了。&lt;/p&gt;&#xA;&lt;p&gt;此外，关于如何确定一个合适的新晶格的大小，也有很多视频讲解，不再赘述。&lt;/p&gt;&#xA;&lt;h3 id=&#34;改变晶体结构的原子层顺序&#34;&gt;改变晶体结构的原子层顺序&lt;/h3&gt;&#xA;&lt;p&gt;即便是只有一种原子的晶体，其沿某个面的堆垛的时候，可能有不同的层。比如FCC晶体沿001面的堆垛方式就是&amp;mdash;ABAB&amp;mdash;，显然与别的物质形成异质结时，会面临一个问题，即是A面还是B面与别的物质接触。&lt;/p&gt;&#xA;&lt;p&gt;我们建模时，需要把A面或B面调整出来。这需要对原子进行整体位移&lt;/p&gt;&#xA;&lt;p&gt;此外，异质结平面内的原子对齐（比如说xy面），也需要对原子进行整体位移。&lt;/p&gt;&#xA;&lt;p&gt;而ASE实现原子整体位移非常简单，只需要用&lt;code&gt;atoms&lt;/code&gt;类的&lt;code&gt;translate&lt;/code&gt;方法即可，注意使用绝对坐标。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ase.build import surface,stack,make_supercell&#xD;&#xA;from ase.io import read,write&#xD;&#xA;from ase.io.vasp import write_vasp&#xD;&#xA;&#xD;&#xA;BiTe = read(&#39;POSCAR_BiTe&#39;)&#xD;&#xA;BiTe = make_supercell(BiTe,P=[[2,0,0],[0,1,0],[0,0,1]])&#xD;&#xA;BiTe1 = BiTe.copy()&#xD;&#xA;BiTe2 = BiTe.copy()&#xD;&#xA;BiTe2.translate([0,0,-2.05985])&#xD;&#xA;BiTe3 = BiTe.copy()&#xD;&#xA;BiTe3.translate([0,0,-3.79553])&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;ase实现超晶格材料建模&#34;&gt;ASE实现超晶格材料建模&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ase.build import surface,stack,make_supercell&#xD;&#xA;from ase.io import read,write&#xD;&#xA;from ase.io.vasp import write_vasp&#xD;&#xA;&#xD;&#xA;BiTe1 = read(&#39;POSCAR_BiTe1&#39;)&#xD;&#xA;BiTe2 = read(&#39;POSCAR_BiTe2&#39;)&#xD;&#xA;BiTe3 = read(&#39;POSCAR_BiTe3&#39;)&#xD;&#xA;&#xD;&#xA;Ag = make_supercell(read(&#39;POSCAR_Ag&#39;),P=[[2,0,0],[0,2,0],[0,0,3]])&#xD;&#xA;BiTe1_Ag = stack(Ag,BiTe1,axis=2,fix=0.5)&#xD;&#xA;BiTe2_Ag = stack(Ag,BiTe2,axis=2,fix=0.5)&#xD;&#xA;BiTe3_Ag = stack(Ag,BiTe3,axis=2,fix=0.5)&#xD;&#xA;&#xD;&#xA;write(&#39;POSCAR_BiTe1_Ag&#39;,BiTe1_Ag,format=&#39;vasp&#39;)&#xD;&#xA;write(&#39;POSCAR_BiTe2_Ag&#39;,BiTe2_Ag,format=&#39;vasp&#39;)&#xD;&#xA;write(&#39;POSCAR_BiTe3_Ag&#39;,BiTe3_Ag,format=&#39;vasp&#39;)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/spl1.png&#34;/&gt;&#xD;&#xA;&lt;h5 id=&#34;关于ase中stack函数的原理&#34;&gt;关于ase中stack函数的原理。&lt;/h5&gt;&#xA;&lt;p&gt;将两个周期性的晶胞合并成一个周期性的晶胞，有一个必须要面对的问题，那就是接触面将不再有周期性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>随机取代晶体结构中的元素</title>
      <link>https://liubaoshuai1402.github.io/dft/%E9%9A%8F%E6%9C%BA%E5%8F%96%E4%BB%A3%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 16 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/dft/%E9%9A%8F%E6%9C%BA%E5%8F%96%E4%BB%A3%E5%85%83%E7%B4%A0/</guid>
      <description>&lt;h1 id=&#34;从一个实例中学习python中的排列组合的实现&#34;&gt;从一个实例中学习python中的排列组合的实现&lt;/h1&gt;&#xA;&lt;h2 id=&#34;zro2中掺杂y元素&#34;&gt;ZrO2中掺杂Y元素&lt;/h2&gt;&#xA;&lt;p&gt;一个96原子的晶胞，去掉一个氧空位，再取代两个Zr原子，就是一个通用的YSZ模型（95 原子）。&lt;/p&gt;&#xA;&lt;p&gt;但是Y与Vo的相对位置，是一个麻烦。&lt;/p&gt;&#xA;&lt;p&gt;Y的掺杂会不会带来晶胞大小的变化。我这里的处理是根据以往的文献，确定一个可能的构型。&lt;/p&gt;&#xA;&lt;p&gt;然后考虑一下掺杂对晶胞尺寸带来的影响，然后就定了，Y再换其他位置也认为不会再影响了。（因为比起相对位置，肯定有无Y原子才是影响的大头）&lt;/p&gt;&#xA;&lt;p&gt;确定了晶胞尺寸，结构优化后，再把Y换成Zr。然后随机取代，最终确定$C_{32}^2$个结构，计算单点能，用于机器学习势学习。&lt;/p&gt;&#xA;&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;&#xA;&lt;p&gt;由大G老师支持。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ase.io import read&#xD;&#xA;from ase.io.vasp import write_vasp&#xD;&#xA;from itertools import combinations&#xD;&#xA;import os&#xD;&#xA;&#xD;&#xA;at = read(&#39;POSCAR&#39;)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 找到所有 Zr 原子的索引&#xD;&#xA;zr_indices = [i for i, atom in enumerate(at) if atom.symbol == &#39;Zr&#39;]&#xD;&#xA;print(f&amp;quot;找到 {len(zr_indices)} 个 Zr 原子&amp;quot;)&#xD;&#xA;&#xD;&#xA;# 创建保存目录&#xD;&#xA;os.makedirs(&amp;quot;ZrO_Y2_structures&amp;quot;, exist_ok=True)&#xD;&#xA;&#xD;&#xA;# 枚举所有 Zr 的两两组合，逐个替换为 Y&#xD;&#xA;for count, (i, j) in enumerate(combinations(zr_indices, 2)):&#xD;&#xA;    new_at = at.copy()&#xD;&#xA;    new_at[i].symbol = &#39;Y&#39;&#xD;&#xA;    new_at[j].symbol = &#39;Y&#39;&#xD;&#xA;&#xD;&#xA;    # 写入文件    &#xD;&#xA;    subdir = f&amp;quot;ZrO_Y2_structures/{count}&amp;quot;&#xD;&#xA;    os.makedirs(subdir, exist_ok=True)&#xD;&#xA;    filename = os.path.join(subdir, &amp;quot;POSCAR&amp;quot;)&#xD;&#xA;    write_vasp(filename, new_at,direct=True,sort=True)&#xD;&#xA;    print(f&amp;quot;写入结构：{filename}&amp;quot;)&#xD;&#xA;&#xD;&#xA;print(f&amp;quot;共生成 {count + 1} 个结构。&amp;quot;)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;combations&lt;/code&gt;类是python中实现组合的高效方式。参数为一个列表，一个长度。返回一个包含若干元组的列表。&lt;/p&gt;</description>
    </item>
    <item>
      <title>COHP</title>
      <link>https://liubaoshuai1402.github.io/dft/cohp/</link>
      <pubDate>Sat, 28 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/dft/cohp/</guid>
      <description>&lt;h1 id=&#34;cohp&#34;&gt;COHP&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;h3 id=&#34;vasp文件的准备&#34;&gt;VASP文件的准备&lt;/h3&gt;&#xA;&lt;p&gt;LOBSTER要求ISYM=0或-1。其他参数没有特殊要求。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;结构优化&lt;/p&gt;&#xA;&lt;p&gt;略过&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;静态自洽&lt;/p&gt;&#xA;&lt;p&gt;以较为简单的K点设置计算波函数、电荷密度。&lt;/p&gt;&#xA;&lt;p&gt;用于得到WAVECAR、CHGCAR&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;#关键参数&#xD;&#xA;ISTART  = 0            &#xD;&#xA;ICHARG  = 2&#xD;&#xA;NSW = 0&#xD;&#xA;NBANDS = 500&#x9;#这个值要大，多试试&#xD;&#xA;NEDOS = 1000&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;后续的非静态自洽的NBANDS和NEDOS尽量和这里保持一致。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;非静态自洽&lt;/p&gt;&#xA;&lt;p&gt;不再更新波函数和电荷密度，进行一次单次的求解。&lt;/p&gt;&#xA;&lt;p&gt;这里可以设置更密的K点来求态密度，也可以设置特殊路径的K点来求能带结构。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;#关键参数&#xD;&#xA;ISTART = 1     # 使用前一轮的波函数&#xD;&#xA;ICHARG = 11    # 使用前一轮的电荷密度，不再更新&#xD;&#xA;NSW = 0&#xD;&#xA;LORBIT = 12&#xD;&#xA;NBANDS = 500&#x9;#这个值要大，多试试&#xD;&#xA;NEDOS = 1000&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;特别说一下LORBIT参数，这个参数是后处理参数，和VASP的电子计算无关。&lt;/p&gt;&#xA;&lt;p&gt;指示VASP生成：DOSCAR and lm-decomposed PROCAR + phase factors (not recommended)&lt;/p&gt;&#xA;&lt;p&gt;所以只需要最后非静态自洽的时候设置即可。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;另外，如果对精度不高，或者不考虑成本，我看也有人直接用静态自洽的结果（这里直接设置比较高的K点密度）进行LOBSTER。&lt;/p&gt;&#xA;&lt;p&gt;如果用的&lt;code&gt;ISMEAR = 0&lt;/code&gt;，后续要在lobsterin文件中指出。&lt;/p&gt;</description>
    </item>
    <item>
      <title>用VASP进行第一性原理分子动力学（AIMD）</title>
      <link>https://liubaoshuai1402.github.io/dft/aimd/</link>
      <pubDate>Sat, 28 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/dft/aimd/</guid>
      <description>&lt;h1 id=&#34;aimd&#34;&gt;AIMD&lt;/h1&gt;&#xA;&lt;h3 id=&#34;nvt系综&#34;&gt;nvt系综&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;ISTART = 0&#xD;&#xA;ENCUT = 480&#xD;&#xA;PREC = Normal&#xD;&#xA;ALGO = Fast&#xD;&#xA;LREAL = Auto&#xD;&#xA;LWAVE = .F. &#xD;&#xA;LCHARG = .F.&#xD;&#xA;GGA = PS&#xD;&#xA;ISMEAR = 0&#xD;&#xA;SIGMA = 0.05&#xD;&#xA;ISPIN = 1&#xD;&#xA;&#xD;&#xA;#electronstep&#xD;&#xA;NELM = 200&#xD;&#xA;NELMIN = 4&#xD;&#xA;EDIFF = 1E-4&#xD;&#xA;&#xD;&#xA;#AIMD&#xD;&#xA;IBRION = 0                  &#xD;&#xA;MDALGO = 2                      &#xD;&#xA;ISIF = 2                         &#xD;&#xA;TEBEG = 1500               &#xD;&#xA;NSW = 5000                     &#xD;&#xA;POTIM = 0.5                    &#xD;&#xA;SMASS = 0.5&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;IBRION&lt;/code&gt;是控制离子步优化算法的参数，进行分子动力学是设置为0。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;MDALGO&lt;/code&gt;这个参数控制恒温器选项。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Honey</title>
      <link>https://liubaoshuai1402.github.io/%E7%94%A8%E5%BF%83%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/honey/</link>
      <pubDate>Thu, 26 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E7%94%A8%E5%BF%83%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/honey/</guid>
      <description>&lt;h1 id=&#34;honey-maker&#34;&gt;Honey maker&lt;/h1&gt;&#xA;&lt;h3 id=&#34;原味轻乳酪芝士蛋糕&#34;&gt;原味轻乳酪芝士蛋糕&lt;/h3&gt;&#xA;&lt;p&gt;来自“糙柔纪软面包”。&lt;/p&gt;&#xA;&lt;p&gt;本次是冰镇口感、不知道新鲜出炉的会怎么样。&lt;/p&gt;&#xA;&lt;p&gt;非常丝滑，入口即化。与常规的蛋糕相比，水感十足。&lt;/p&gt;&#xA;&lt;p&gt;足够甜，包裹了一点点酸。&lt;/p&gt;&#xA;&lt;p&gt;底部硬硬的，据说是饼干。&lt;/p&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/%E8%BD%BB%E4%B9%B3%E9%85%AA%E8%8A%9D%E5%A3%AB%E8%9B%8B%E7%B3%95.jpg&#34; style=&#34;zoom: 33%;&#34; /&gt;&#xD;&#xA;&lt;h3 id=&#34;碱水棒&#34;&gt;碱水棒&lt;/h3&gt;&#xA;&lt;p&gt;据说是来自德国的碱水面包。&lt;/p&gt;&#xA;&lt;p&gt;大美食家本人的评价是，甚不豪赤。&lt;/p&gt;&#xA;&lt;p&gt;很干，面包本身没有味道，全靠红豆支撑。（是不是隔夜放了一天的缘故？）&lt;/p&gt;&#xA;&lt;p&gt;没有下次，避雷！&lt;/p&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/%E7%A2%B1%E6%B0%B4%E6%A3%92.jpg&#34; style=&#34;zoom:33%;&#34; /&gt;</description>
    </item>
    <item>
      <title>DeepMD入门</title>
      <link>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/deepmd%E5%85%A5%E9%97%A8/</link>
      <pubDate>Wed, 18 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/deepmd%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h1 id=&#34;deepmd入门&#34;&gt;DeepMD入门&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;之前一直用的mace，现在来了解一下deepmd吧。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1dp的数据集结构&#34;&gt;1.dp的数据集结构&lt;/h3&gt;&#xA;&lt;p&gt;与mace相对简单的数据集结构相比（只需提供打标签后xyz文件），dp组织它的数据集以一种相对不自由的形式，但也更加清楚明了。&lt;/p&gt;&#xA;&lt;p&gt;dp的数据集是由dpdata处理DFT结果得到的。一个标准的dp数据集路径下，包含了三种文件，分别是：&lt;code&gt;type.raw&lt;/code&gt;、&lt;code&gt;type_map.raw&lt;/code&gt;和&lt;code&gt;set.000&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;type.raw&lt;/code&gt;其实就是POSCAR中的原子，只不过把元素符号换成了数字。&lt;code&gt;type_map.raw&lt;/code&gt;则是保留了数字到元素符号的映射关系。&lt;/p&gt;&#xA;&lt;p&gt;&lt;del&gt;很困惑为什么要这样设计&lt;/del&gt;&lt;/p&gt;&#xA;&lt;p&gt;set.000文件夹则是存放DFT标签的，具体如坐标、能量、力等。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2如何生成数据集&#34;&gt;2.如何生成数据集&lt;/h3&gt;&#xA;&lt;p&gt;任务：想象一下，你有多个OUTCAR，分别是：&lt;/p&gt;&#xA;&lt;p&gt;1000K下：C、O体系；C、O、H体系&lt;/p&gt;&#xA;&lt;p&gt;2000K下：C、O体系；C、O、H体系&lt;/p&gt;&#xA;&lt;p&gt;如何把他们整合成训练集和数据集呢？&lt;/p&gt;&#xA;&lt;p&gt;每个体系AIMD的OUTCAR包含10000个轨迹。但因为相邻轨迹的结构比较接近，我们决定每100步取一个结构作为数据集。&lt;/p&gt;&#xA;&lt;p&gt;现在你有以下路径，&lt;code&gt;1000K/CO/OUTCAR&lt;/code&gt;、&lt;code&gt;1000K/COH/OUTCAR&lt;/code&gt;、&lt;code&gt;2000K/CO/OUTCAR&lt;/code&gt;、&lt;code&gt;2000K/COH/OUTCAR&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;此外呢，如果把这四体系合并后再划分训练集、验证集，随机性会更大，比如说某个体系的训练集取得很多，而某个体系则几乎全被当作验证集。&lt;/p&gt;&#xA;&lt;p&gt;为了避免这样的事情发生，我们可以先把每个体系划分成小的训练集、验证区，然后把这些小的训练集、验证集合并。&lt;/p&gt;&#xA;&lt;p&gt;这就是总体思路，来看看怎么实现吧。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import dpdata&#xD;&#xA;import numpy as np&#xD;&#xA;#生成一个列表用于dpdata取子集的索引，dpdata的system并不支持直接的切片规则，很无语&#xD;&#xA;#从第1个结构到1w个，每100步取一个，很灵活，可以自由改变起始，结束和步长&#xD;&#xA;IndicesInitial = list(range(0,10000,100))&#xD;&#xA;#从100个结构的索引中随机取20个作为验证集，20%&#xD;&#xA;np.random.seed(42)&#xD;&#xA;ValidIndices = list(np.random.choice(IndicesInitial,20,replace=None))&#xD;&#xA;#从数据集中剔除验证集，得到训练集，这里为了实现列表元素进行集合运算，先把他们变成集合&#xD;&#xA;TrainIndices = list(set(IndicesInitial)-set(ValidIndices))&#xD;&#xA;#只读了一个OUTCAR作为例子，适当修改&#xD;&#xA;dpSystem = dpdata.LabeledSystem(&#39;1000K/CO/OUTCAR&#39;)&#xD;&#xA;&#xD;&#xA;dpSystemTrain = dpSystem.sub_system(TrainIndices)&#xD;&#xA;dpSystemTrain.to(&amp;quot;deepmd/npy&amp;quot;, &amp;quot;trainset/1000K/CO&amp;quot;, set_size=dpSystemTrain.get_nframes())&#xD;&#xA;&#xD;&#xA;dpSystemValid = dpSystem.sub_system(ValidIndices)&#xD;&#xA;dpSystemValid.to(&amp;quot;deepmd/npy&amp;quot;, &amp;quot;validset/1000K/CO&amp;quot;, set_size=dpSystemValid.get_nframes())&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;set_size=dpSystemTrain.get_nframes()&lt;/code&gt;,关于set的尺寸为什么要正好等于所有结构，这个问题追溯起来非常远古。&lt;/p&gt;&#xA;&lt;p&gt;曾经dp的开发者应该希望一个system下有多个set.00x，最后一个set.00x作为测试集。但后来他们放弃了。&lt;/p&gt;&#xA;&lt;p&gt;所以现在的用法是，只要一个set.000即可，至于这个system下的数据用于训练、验证，在input.json中说明即可。&lt;/p&gt;&#xA;&lt;p&gt;顺带一提，dp训练模型时并不要求测试集，mace的话则可以提供。&lt;/p&gt;&#xA;&lt;p&gt;下图是input.json的一部分：&lt;/p&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/dp1.png&#34; style=&#34;zoom:67%;&#34; /&gt;&#xD;&#xA;&lt;p&gt;把相应路径替换成&lt;code&gt;&amp;quot;trainset/1000K/CO&amp;quot;&lt;/code&gt;等等即可&lt;/p&gt;&#xA;&lt;p&gt;dp中system的概念，同一个system中，结构涉及的元素和原子个数应该完全相同。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3利用dpdata生成扰动结构&#34;&gt;3.利用dpdata生成扰动结构&lt;/h3&gt;&#xA;&lt;p&gt;dpdata本身已经提供了很好的&#xD;&#xA;&lt;a href=&#34;https://docs.deepmodeling.com/projects/dpdata/en/master/systems/system.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;示例&lt;/a&gt;&#xD;&#xA;, 这里简单搬运一下，并添加了一个更深入的应用场景。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LAMMPS-dump</title>
      <link>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/dump/</link>
      <pubDate>Tue, 17 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/dump/</guid>
      <description>&lt;h1 id=&#34;有用的dump&#34;&gt;有用的dump&lt;/h1&gt;&#xA;&lt;h3 id=&#34;1-如何由lammps的轨迹转化为poscar&#34;&gt;1. 如何由lammps的轨迹转化为POSCAR&lt;/h3&gt;&#xA;&lt;p&gt;构建机器学习势时，通常需要主动学习。主动学习就需要将用MLIAP跑出来的结果返回到DFT中进行计算。&lt;/p&gt;&#xA;&lt;p&gt;具体来讲，要将分子动力学轨迹转化为第一性原理的输入格式。（如从lammps到vasp）&lt;/p&gt;&#xA;&lt;p&gt;lammps并不直接支持输出POSCAR格式，比较容易想到的思路是让lammps输出xyz文件，再有xyz文件转化为POSCAR。&lt;/p&gt;&#xA;&lt;p&gt;不过麻烦的一点是，lammps输出xyz文件并不带有晶格大小的信息，无法转化为POSCAR。&lt;/p&gt;&#xA;&lt;p&gt;这里，我目前的方案是，先用custom style的dump输出文件，如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;dump          1 all custom 1 dump20nvt id element x y z&#xD;&#xA;dump_modify   1 sort id element O Zr Y H&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;为了避免输出lammps中的type，而不是元素符号，这里修饰一下dump（即 &lt;code&gt;element O Zr Y H&lt;/code&gt;），这里O、Zr、Y、H分别对应 type 1、2、3、4&lt;/p&gt;&#xA;&lt;p&gt;sort id 必不可少，保证原子对应。&lt;/p&gt;&#xA;&lt;p&gt;这样得到的dump文件格式，如下：&lt;/p&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/dump%E7%9A%84custom%E9%A3%8E%E6%A0%BC.png&#34; style=&#34;zoom:70%;&#34; /&gt;&#xD;&#xA;&lt;p&gt;可以看到，同时包含了元素符号、晶格和原子坐标信息。其实这个自定义风格，&lt;code&gt;custom&lt;/code&gt;，就是稍加修改的&lt;code&gt;atom&lt;/code&gt;风格。&lt;/p&gt;&#xA;&lt;p&gt;剩下的问题就是，如何将lammps的dump文件转化为xyz文件，再由xyz文件转化为POSCAR。&lt;/p&gt;&#xA;&lt;p&gt;OVITO模块读取dump文件比较好用，个人觉得比ase的强，所以这里采用ovito模块，如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ovito.io import import_file,export_file&#xD;&#xA;&#xD;&#xA;pipeline = import_file(&#39;dump&#39;)&#xD;&#xA;&#xD;&#xA;for frame,data in enumerate(pipeline.frames):&#xD;&#xA;    if frame &amp;lt; 10:&#xD;&#xA;        export_file(data,&amp;quot;xyz{}&amp;quot;.format(frame),format=&amp;quot;xyz&amp;quot;,columns =[&amp;quot;Particle Identifier&amp;quot;, &amp;quot;Particle Type&amp;quot;, &amp;quot;Position.X&amp;quot;, &amp;quot;Position.Y&amp;quot;, &amp;quot;Position.Z&amp;quot;])&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这里简单测试一下，只输出了前10个结构。结果很成功。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LAMMPS中的常见命令</title>
      <link>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/lammps%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 17 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/lammps%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</guid>
      <description>&lt;h1 id=&#34;lammps中的常见命令&#34;&gt;LAMMPS中的常见命令&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;虽然说是常见，但也未必常见吧，可能只是我遇到的不懂的、或者觉得有趣的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1labelmap&#34;&gt;1.&lt;code&gt;labelmap&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;lablemap atom 1 H 2 O&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;这个命令用于给atom type指定一个映射关系。在用&lt;code&gt;write_data&lt;/code&gt;写当前帧的data文件时，文件会含有额外的信息，如下：&lt;/p&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/labelmap.png&#34; style=&#34;zoom:60%;&#34; /&gt;&#xD;&#xA;&lt;p&gt;但只限于data文件，无法影响dump的轨迹文件，所以想要写带有元素符号的轨迹，还是用dump的custom风格比较好。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-variable&#34;&gt;2. &lt;code&gt;variable&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;想要精通LAMMPS中的&lt;code&gt;variable&lt;/code&gt;总是要费一番功夫的，今日有幸认真研究一番（本身又涉及很多别的命令，真似高中时看牛津字典，遇到一个个新单词，好爽快）。&lt;/p&gt;&#xA;&lt;p&gt;不同风格的&lt;code&gt;variable&lt;/code&gt;的&lt;mark&gt;定义&lt;/mark&gt;和&lt;mark&gt;使用&lt;/mark&gt;，会有一些差异。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;variable name style args ...&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这是官方给出的&lt;code&gt;variable&lt;/code&gt;语法，简明扼要，&lt;code&gt;variable&lt;/code&gt;由名字、风格、参数组成。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;equal&lt;/code&gt;风格&lt;/p&gt;&#xA;&lt;p&gt;它后接一个公式，可以包含：数字、常数、数学算符、内置函数、原子值（atom values）、原子矢量（atom vectors）以及compute/fix/variable的引用。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;  atom value = id[i], mass[i], type[i], mol[i], x[i], y[i], z[i], vx[i], vy[i], vz[i], fx[i], fy[i], fz[i], q[i]&#xD;&#xA;  atom vector = id, mass, type, mol, radius, q, x, y, z, vx, vy, vz, fx, fy, f&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这里，原子值是某个原子的信息，而原子矢量则是包含全体原子的信息。&lt;/p&gt;&#xA;&lt;p&gt;值得注意的是，如果涉及到原子值，在&lt;code&gt;atom_style&lt;/code&gt;之后，还要打开&lt;code&gt;atom_modify map yes&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LAMMPS剪切模拟</title>
      <link>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/lammps%E5%89%AA%E5%88%87%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Sat, 14 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/lammps%E5%89%AA%E5%88%87%E6%A8%A1%E6%8B%9F/</guid>
      <description>&lt;h1 id=&#34;lammps用于剪切模拟的in文件&#34;&gt;LAMMPS用于剪切模拟的in文件&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 3d metal shear simulation&#xD;&#xA;&#xD;&#xA;units&#x9;&#x9;metal&#xD;&#xA;boundary&#x9;s s p&#xD;&#xA;&#xD;&#xA;atom_style&#x9;atomic&#xD;&#xA;lattice&#x9;&#x9;fcc 3.52&#xD;&#xA;region&#x9;&#x9;box block 0 16.0 0 10.0 0 2.828427&#xD;&#xA;create_box&#x9;3 box&#xD;&#xA;&#xD;&#xA;lattice&#x9;&#x9;fcc 3.52 orient&#x9;x 1 0 0 orient y 0 1 1 orient z 0 -1 1 &amp;amp;&#xD;&#xA;&#x9;&#x9;origin 0.5 0 0 &#xD;&#xA;create_atoms&#x9;1 box&#xD;&#xA;&#xD;&#xA;pair_style&#x9;eam&#xD;&#xA;pair_coeff&#x9;* * Ni_u3.eam&#xD;&#xA;&#xD;&#xA;neighbor&#x9;0.3 bin&#xD;&#xA;neigh_modify&#x9;delay 5&#xD;&#xA;&#xD;&#xA;region&#x9;&#x9;lower block INF INF INF 0.9 INF INF&#xD;&#xA;region&#x9;&#x9;upper block INF INF 6.1 INF INF INF&#xD;&#xA;group&#x9;&#x9;lower region lower&#xD;&#xA;group&#x9;&#x9;upper region upper&#xD;&#xA;group&#x9;&#x9;boundary union lower upper&#xD;&#xA;group&#x9;&#x9;mobile subtract all boundary&#xD;&#xA;&#xD;&#xA;set&#x9;&#x9;group lower type 2&#xD;&#xA;set&#x9;&#x9;group upper type 3&#xD;&#xA;&#xD;&#xA;# void&#xD;&#xA;&#xD;&#xA;#region&#x9;&#x9;void cylinder z 8 5 2.5 INF INF&#xD;&#xA;#delete_atoms&#x9;region void&#xD;&#xA;&#xD;&#xA;# temp controllers&#xD;&#xA;&#xD;&#xA;compute&#x9;&#x9;new3d mobile temp&#xD;&#xA;compute&#x9;&#x9;new2d mobile temp/partial 0 1 1&#xD;&#xA;&#xD;&#xA;# equilibrate&#xD;&#xA;&#xD;&#xA;velocity&#x9;mobile create 300.0 5812775 temp new3d&#xD;&#xA;fix&#x9;&#x9;1 all nve&#xD;&#xA;fix&#x9;&#x9;2 boundary setforce 0.0 0.0 0.0&#xD;&#xA;&#xD;&#xA;fix&#x9;&#x9;3 mobile temp/rescale 10 300.0 300.0 10.0 1.0&#xD;&#xA;fix_modify&#x9;3 temp new3d&#xD;&#xA;&#xD;&#xA;thermo&#x9;&#x9;25&#xD;&#xA;thermo_modify&#x9;temp new3d&#xD;&#xA;&#xD;&#xA;timestep&#x9;0.001&#xD;&#xA;run&#x9;&#x9;100&#xD;&#xA;&#xD;&#xA;# shear&#xD;&#xA;&#xD;&#xA;velocity&#x9;upper set 1.0 0 0&#xD;&#xA;velocity&#x9;mobile ramp vx 0.0 1.0 y 1.4 8.6 sum yes&#xD;&#xA;&#xD;&#xA;unfix&#x9;&#x9;3&#xD;&#xA;fix&#x9;&#x9;3 mobile temp/rescale 10 300.0 300.0 10.0 1.0&#xD;&#xA;fix_modify&#x9;3 temp new2d&#xD;&#xA;&#xD;&#xA;#dump&#x9;&#x9;1 all atom 100 dump.shear&#xD;&#xA;&#xD;&#xA;#dump&#x9;&#x9;2 all image 100 image.*.jpg type type &amp;amp;&#xD;&#xA;#&#x9;&#x9;axes yes 0.8 0.02 view 0 0 zoom 1.5 up 0 1 0 adiam 2.0&#xD;&#xA;#dump_modify&#x9;2 pad 4&#xD;&#xA;&#xD;&#xA;#dump&#x9;&#x9;3 all movie 100 movie.mpg type type &amp;amp;&#xD;&#xA;#&#x9;&#x9;axes yes 0.8 0.02 view 0 0 zoom 1.5 up 0 1 0 adiam 2.0&#xD;&#xA;#dump_modify&#x9;3 pad 4&#xD;&#xA;&#xD;&#xA;thermo&#x9;&#x9;100&#xD;&#xA;thermo_modify&#x9;temp new2d&#xD;&#xA;&#xD;&#xA;reset_timestep&#x9;0&#xD;&#xA;run&#x9;&#x9;3000&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;compute--id--group-id--temp&#34;&gt;&lt;code&gt;compute  ID  group-ID  temp&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;计算某个原子群的温度&lt;/p&gt;</description>
    </item>
    <item>
      <title>超算操作</title>
      <link>https://liubaoshuai1402.github.io/%E8%B6%85%E7%AE%97/%E8%B6%85%E7%AE%97%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 04 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E8%B6%85%E7%AE%97/%E8%B6%85%E7%AE%97%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;h1 id=&#34;超算中心&#34;&gt;超算中心&lt;/h1&gt;&#xA;&lt;h3 id=&#34;安装nvcc和pytorch&#34;&gt;安装nvcc和pytorch&lt;/h3&gt;&#xA;&lt;p&gt;先用conda安装&lt;code&gt;cuda-toolkit&lt;/code&gt;，&lt;code&gt;-&lt;/code&gt;不能省略。这里我选择的12.6版本，之前试了12.9，编译lammps的时候报错了。&lt;/p&gt;&#xA;&lt;p&gt;再用pip安装&lt;code&gt;pytorch&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;用conda安装nvcc后，lammps的nvcc_wrapper可能找不到cuda_runtime.h，可以手动指定&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;export CPLUS_INCLUDE_PATH=/home-ssd/Users/nsgm_zcx/miniconda3/envs/mace/targets/x86_64-linux/include:$CPLUS_INCLUDE_PATH&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;加载模块&#34;&gt;加载模块&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;source /home-ssd/hpc/ini_module.bash&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;export MODULEPATH=/home-ssd/hpc/modulefiles:/home-ssd/Soft/modules/modulefiles/Soft&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;export MODULEPATH=/home-ssd/hpc/modulefiles&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;module av&lt;/code&gt;查看当前可用模块&lt;/p&gt;&#xA;&lt;h3 id=&#34;联网&#34;&gt;联网&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;ssh gn001&lt;/code&gt;进入编译节点&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;source /home-ssd/Soft/modules/bashrc&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;module load proxy/proxy&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;openmpi&#34;&gt;openmpi&lt;/h3&gt;&#xA;&lt;p&gt;下载后解压，进入发行版的文件夹，然后创建一个&lt;code&gt;build&lt;/code&gt;文件夹用于编译和安装。&lt;/p&gt;&#xA;&lt;p&gt;安装命令，在build文件夹中运行：&lt;code&gt;../configure --prefix=/home-ssd/Users/nsgm_zcx/openmpi-5.0.5/build --with-slurm 2&amp;gt;&amp;amp;1 | tee config.out&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;export PATH=/home-ssd/Users/nsgm_zcx/openmpi-5.0.5/build/bin:$PATH&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;export LD_LIBRARY_PATH=/home-ssd/Users/nsgm_zcx/openmpi-5.0.5/build/lib:$LD_LIBRARY_PATH&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;lammps&#34;&gt;LAMMPS&lt;/h3&gt;&#xA;&lt;p&gt;cmake的编译缓存可能会记录错误的依赖路径，即使自己下载了新的openmpi，也会因为没有及时更新而报错找不到。&lt;/p&gt;&#xA;&lt;p&gt;所以要删干净，再进行一次cmake。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;export PATH=/home-ssd/Users/nsgm_zcx/lammps-develop/build-mliap:$PATH&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;zlib&#34;&gt;zlib&lt;/h3&gt;&#xA;&lt;p&gt;安装完&lt;code&gt;cuda-toolkit&lt;/code&gt;和&lt;code&gt;pytorch&lt;/code&gt;后，conda自动安装的zlib可能只是&lt;code&gt;libzlib&lt;/code&gt;，只有库，没有&lt;mark&gt;头文件&lt;/mark&gt;，需要手动安装一个完整的&lt;code&gt;zlib&lt;/code&gt;，保证lammps编译的时候不报错。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;conda install zlib&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;提交任务&#34;&gt;提交任务&lt;/h4&gt;&#xA;&lt;p&gt;gpu任务&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash&#xD;&#xA;#SBATCH -o job.%j.out&#xD;&#xA;#SBATCH -e job.%j.out&#xD;&#xA;#SBATCH -J lmp_job_gpu&#xD;&#xA;#SBATCH --partition=gpu        &#xD;&#xA;#SBATCH -N 1                    &#xD;&#xA;#SBATCH -G 1&#xD;&#xA;#SBATCH --gres=gpu:1&#xD;&#xA;#SBATCH --exclusive&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;export PATH=/home-ssd/Users/nsgm_zcx/openmpi-5.0.5/build/bin:$PATH&#xD;&#xA;export LD_LIBRARY_PATH=/home-ssd/Users/nsgm_zcx/openmpi-5.0.5/build/lib:$LD_LIBRARY_PATH&#xD;&#xA;export PATH=/home-ssd/Users/nsgm_zcx/lammps-develop/build-mliap:$PATH&#xD;&#xA;&#xD;&#xA;source /home-ssd/Users/nsgm_zcx/miniconda3/etc/profile.d/conda.sh&#xD;&#xA;conda activate cuda&#xD;&#xA;&#xD;&#xA;mace_run_train --config parameters.yaml&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;cpu任务&lt;/p&gt;</description>
    </item>
    <item>
      <title>绘制DFT数据和MACE预测值的关系图</title>
      <link>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/dft%E6%95%B0%E6%8D%AEvsmace%E9%A2%84%E6%B5%8B%E5%80%BC/</link>
      <pubDate>Thu, 29 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/dft%E6%95%B0%E6%8D%AEvsmace%E9%A2%84%E6%B5%8B%E5%80%BC/</guid>
      <description>&lt;h1 id=&#34;绘制dft数据和mace预测值的关系图&#34;&gt;绘制DFT数据和MACE预测值的关系图&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;本文主要搬运一下&#xD;&#xA;&lt;a href=&#34;https://colab.research.google.com/drive/1ZrTuTvavXiCxTFyjBV4GqlARxgFwYAtX#scrollTo=v75wGSfOw9dA&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;MACE教程其一&lt;/a&gt;&#xD;&#xA;，记录一下如何绘制DFT数据和MACE预测值的关系图，用于评估模型的准确性，加上一些自己的理解。&lt;/p&gt;&#xA;&lt;p&gt;软件：ASE、&#xD;&#xA;&lt;a href=&#34;https://github.com/imagdau/aseMolec&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;aseMolec&lt;/a&gt;&#xD;&#xA;、matplotlib、numpy&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;准备评估函数&#34;&gt;准备评估函数&lt;/h2&gt;&#xA;&lt;p&gt;MACE官方写好了评估的命令行脚本，我们这里给它一个虚拟参数，方便以编程的方式调用它。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from mace.cli.eval_configs import main as mace_eval_configs_main&#xD;&#xA;import sys&#xD;&#xA;&#xD;&#xA;def eval_mace(configs, model, output):&#xD;&#xA;    sys.argv = [&amp;quot;program&amp;quot;, &amp;quot;--configs&amp;quot;, configs, &amp;quot;--model&amp;quot;, model, &amp;quot;--output&amp;quot;, output]&#xD;&#xA;    mace_eval_configs_main()&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这里的&lt;code&gt;eval_mace&lt;/code&gt;函数接受三个参数，数据集如训练集、测试集的路径、训练好的模型的路径以及输出的文件命。&lt;/p&gt;&#xA;&lt;h2 id=&#34;评估数据集&#34;&gt;评估数据集&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#evaluate the training set&#xD;&#xA;eval_mace(configs=&amp;quot;data/solvent_xtb_train_200.xyz&amp;quot;,&#xD;&#xA;          model=&amp;quot;MACE_models/mace01_run-123_stagetwo.model&amp;quot;,&#xD;&#xA;          output=&amp;quot;tests/mace01/solvent_train.xyz&amp;quot;)&#xD;&#xA;&#xD;&#xA;#evaluate the test set&#xD;&#xA;eval_mace(configs=&amp;quot;data/solvent_xtb_test.xyz&amp;quot;,&#xD;&#xA;          model=&amp;quot;MACE_models/mace01_run-123_stagetwo.model&amp;quot;,&#xD;&#xA;          output=&amp;quot;tests/mace01/solvent_test.xyz&amp;quot;)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这样，MACE就会对数据集进行评估，因为其实DFT数据是已有的，主要是在输出文件中，补上MACE的预测值。&lt;/p&gt;&#xA;&lt;h2 id=&#34;画图&#34;&gt;画图&lt;/h2&gt;&#xA;&lt;p&gt;然后就可以用aseMolec的如下代码进行画图了&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from aseMolec import pltProps as pp&#xD;&#xA;from ase.io import read&#xD;&#xA;import matplotlib.pyplot as plt&#xD;&#xA;from aseMolec import extAtoms as ea&#xD;&#xA;import numpy as np&#xD;&#xA;&#xD;&#xA;def plot_RMSEs(db, labs):&#xD;&#xA;    ea.rename_prop_tag(db, &#39;MACE_energy&#39;, &#39;energy_mace&#39;) #Backward compatibility&#xD;&#xA;    ea.rename_prop_tag(db, &#39;MACE_forces&#39;, &#39;forces_mace&#39;) #Backward compatibility&#xD;&#xA;&#xD;&#xA;    plt.figure(figsize=(9,6), dpi=100)&#xD;&#xA;    plt.subplot(1,3,1)&#xD;&#xA;    pp.plot_prop(ea.get_prop(db, &#39;bind&#39;, &#39;_xtb&#39;, True).flatten(), \&#xD;&#xA;                 ea.get_prop(db, &#39;bind&#39;, &#39;_mace&#39;, True).flatten(), \&#xD;&#xA;                 title=r&#39;Energy $(\rm eV/atom)$ &#39;, labs=labs, rel=False)&#xD;&#xA;    plt.subplot(1,3,2)&#xD;&#xA;    pp.plot_prop(ea.get_prop(db, &#39;info&#39;, &#39;energy_xtb&#39;, True).flatten(), \&#xD;&#xA;                 ea.get_prop(db, &#39;info&#39;, &#39;energy_mace&#39;, True).flatten(), \&#xD;&#xA;                 title=r&#39;Energy $(\rm eV/atom)$ &#39;, labs=labs, rel=False)&#xD;&#xA;    plt.subplot(1,3,3)&#xD;&#xA;    pp.plot_prop(np.concatenate(ea.get_prop(db, &#39;arrays&#39;, &#39;forces_xtb&#39;)).flatten(), \&#xD;&#xA;                 np.concatenate(ea.get_prop(db, &#39;arrays&#39;, &#39;forces_mace&#39;)).flatten(), \&#xD;&#xA;                 title=r&#39;Forces $\rm (eV/\AA)$ &#39;, labs=labs, rel=False)&#xD;&#xA;    plt.tight_layout()&#xD;&#xA;    return&#xD;&#xA;&#xD;&#xA;train_data = read(&#39;tests/mace01/solvent_train.xyz&#39;, &#39;:&#39;)&#xD;&#xA;test_data = train_data[:3]+read(&#39;tests/mace01/solvent_test.xyz&#39;, &#39;:&#39;) #append the E0s for computing atomization energy errors&#xD;&#xA;&#xD;&#xA;plot_RMSEs(train_data, labs=[&#39;XTB&#39;, &#39;MACE&#39;])&#xD;&#xA;plot_RMSEs(test_data, labs=[&#39;XTB&#39;, &#39;MACE&#39;])&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;plot_RMSEs&lt;/code&gt;函数中首先把标签重命名了一下，因为MACE的源代码&lt;code&gt;mace_eval_configs_main()&lt;/code&gt;部分默认打的标签是&lt;code&gt;MACE_&lt;/code&gt;+什么什么的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图池化</title>
      <link>https://liubaoshuai1402.github.io/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E6%B1%A0%E5%8C%96/</link>
      <pubDate>Wed, 28 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E6%B1%A0%E5%8C%96/</guid>
      <description></description>
    </item>
    <item>
      <title>晶界建模</title>
      <link>https://liubaoshuai1402.github.io/pymatgen/gainbroundary/</link>
      <pubDate>Sat, 24 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/pymatgen/gainbroundary/</guid>
      <description>&lt;h1 id=&#34;晶界建模&#34;&gt;晶界建模&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;基于&#xD;&#xA;&lt;a href=&#34;https://dtrinkle.matse.illinois.edu/MatSE584/kap_7/backbone/r7_1_2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;共格点阵模型&lt;/a&gt;&#xD;&#xA;（Coincidence Site Lattice），使用pymatgen进行晶界建模。&lt;/p&gt;&#xA;&lt;h2 id=&#34;晶界的类型&#34;&gt;晶界的类型&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-扭转twist晶界&#34;&gt;1. 扭转（twist）晶界&lt;/h3&gt;&#xA;&lt;p&gt;旋转轴垂直于晶界面，也就是两者的密勒指数应该成比列。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-倾斜tilt晶界&#34;&gt;2. 倾斜（tilt）晶界&lt;/h3&gt;&#xA;&lt;p&gt;旋转轴平行于晶界面，也就是两者的密勒指数的点乘为0。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-混合mixed晶界&#34;&gt;3. 混合（mixed）晶界&lt;/h3&gt;&#xA;&lt;p&gt;旋转轴既不垂直也不平行于晶界面。&lt;/p&gt;&#xA;&lt;p&gt;基于共格点阵模型的晶界命名法，Σ+number(must be odd)+(hkl)/[uvw]。&lt;/p&gt;&#xA;&lt;p&gt;举一个栗子， Σ13 (510)/[001] symmetric tilt grain-boundary。&lt;/p&gt;&#xA;&lt;p&gt;这里Σ的大小，是指旋转后重合点阵的单胞的提及是原始晶体单胞的体积的多少倍。通常，这个数字越大，代表两个晶粒的取向相差越远，晶界能也往往越远。&lt;/p&gt;&#xA;&lt;p&gt;Σ1则代表趋向一致，那些小角度晶界也被认为Σ的值近似于1。&lt;/p&gt;&#xA;&lt;p&gt;当指明是twist or tilt晶界时，有时可以省略晶向，也不会造成歧义，比如，&lt;mark&gt;the Σ5(310) tilt GB&lt;/mark&gt;，这是一个YSZ中典型的低能量晶界。&lt;/p&gt;&#xA;&lt;p&gt;但它没有给出旋转轴，因为没有必要，tilt GB 要求晶界面与旋转轴平行，所以只能是[001]。&lt;/p&gt;&#xA;&lt;h2 id=&#34;使用pymatgen进行晶界建模&#34;&gt;使用pymatgen进行晶界建模&lt;/h2&gt;&#xA;&lt;p&gt;首先，我们假设一个应用场景，就是说，我们建模肯定是根据实验来的，实验上对哪些晶界感兴趣，我们就去建模研究。&lt;/p&gt;&#xA;&lt;p&gt;所以在这个假设的基础上，我们是知道&lt;mark&gt;Σ的值&lt;/mark&gt;以及&lt;mark&gt;旋转轴&lt;/mark&gt;、&lt;mark&gt;晶界面&lt;/mark&gt;的。&lt;/p&gt;&#xA;&lt;p&gt;这样，用以下代码我们可以得到旋转角。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pymatgen.core import Structure&#xD;&#xA;from pymatgen.core.interface import GrainBoundaryGenerator&#xD;&#xA;&#xD;&#xA;# 1. 读取结构文件&#xD;&#xA;structure = Structure.from_file(&amp;quot;ZrO.cif&amp;quot;)&#xD;&#xA;structure = structure.to_conventional()&#xD;&#xA;&#xD;&#xA;#创建一个晶界生成器，实例化需要一个晶体结构，最好是conventional cell。&#xD;&#xA;gb_gen = GrainBoundaryGenerator(structure)&#xD;&#xA;&#xD;&#xA;# 2. 构建 Σ5 晶界，参数分别对应Σ的值、旋转轴、晶格类型，对非立方体系需要指定轴比&#xD;&#xA;#其实这里感觉很奇怪，轴比和晶格类型，pymatgen不应该自己判断吗，感觉这块代码写的不好&#xD;&#xA;rotation_anglen = gb_gen.get_rotation_angle_from_sigma(5,(0,0,1),lat_type=&#39;c&#39;)&#xD;&#xA;print(rotation_anglen)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这里的输出是，[36.86989764584402, 53.13010235415597, 126.86989764584402, 143.13010235415598]。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Pytorch中的张量操作</title>
      <link>https://liubaoshuai1402.github.io/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%BC%A0%E9%87%8F%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 20 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%BC%A0%E9%87%8F%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;h1 id=&#34;pytorch中的张量操作&#34;&gt;Pytorch中的张量操作&lt;/h1&gt;&#xA;&lt;h2 id=&#34;数学符号&#34;&gt;数学符号&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1--运算符&#34;&gt;1. * 运算符&lt;/h3&gt;&#xA;&lt;p&gt;如果张量的形状完全一样，张量 * 张量，其实就是对应元素相乘，也可以$\odot$表示。&lt;/p&gt;&#xA;&lt;p&gt;如果张量的形状不一样，则要求他们的形状只能在一个维度上不一样，且其中一个张量这个维度的&lt;code&gt;size&lt;/code&gt;为1，这样可以用广播机制补全后相乘。&lt;/p&gt;&#xA;&lt;p&gt;如果张量 * 数字，则是全体元素乘以这个数字。&lt;/p&gt;&#xA;&lt;h2 id=&#34;函数方法&#34;&gt;函数、方法&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-permute&#34;&gt;1. &lt;code&gt;permute()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;可以作为张量对象的方法使用，接受置换后的维度。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch&#xD;&#xA;&#xD;&#xA;table = torch.randn(2,3,4)&#xD;&#xA;print(table)&#xD;&#xA;print(table.permute(2,1,0))&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这段代码就是将第一维和第三维进行置换。&lt;/p&gt;&#xA;&lt;p&gt;由已知的张量还有置换后的顺序，怎么写出新的张量呢，这个问题一直让我困扰。&lt;/p&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/permute.jpg&#34; style=&#34;zoom:50%;&#34; /&gt;&#xD;&#xA;&lt;p&gt;今天的学习，我脑子里突然蹦出一个邻居的概念。对于一个四维的张量元素，它应该有四个不同维度的邻居，但如果仅仅把视角局限在矩阵里，那它就只有两个邻居，一个行维度上的，一个列维度上的，这很不对。得把视野打开，通道维度和批次维度的邻居可能隔了很远，但它们也是邻居。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-reshape和view&#34;&gt;2. &lt;code&gt;reshape()&lt;/code&gt;和&lt;code&gt;view()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;深度学习中，经常会把高维张量降维，计算后再展开，要小心翼翼，错位会带来灾难性的错误。&lt;/p&gt;&#xA;&lt;p&gt;对于一个（N，F，M）的张量，F是其特征维度。如果想把N和M合并，&lt;mark&gt;应该先把F变成最高维度或者最低维度，让需要合并的维度接壤&lt;/mark&gt;。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch&#xD;&#xA;&#xD;&#xA;table = torch.randn(2,3,4)&#xD;&#xA;print(table)&#xD;&#xA;a = table.reshape(3,8)&#xD;&#xA;b = table.permute(1,0,2).reshape(3,8)&#xD;&#xA;&#xD;&#xA;print(a)&#xD;&#xA;print(b)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这里先把张量形状变成了（3，2，4），再合并，可以保证张量维度不会错位，如果直接改写性质为（3，8），则会错位。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;reshape()&lt;/code&gt;和&lt;code&gt;view()&lt;/code&gt;是一样的，前者可以作用于numpy数组。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-flatten&#34;&gt;3. &lt;code&gt;flatten()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;将高维张量展平为一维张量。&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-torchcat&#34;&gt;4. &lt;code&gt;torch.cat()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;把张量按给定的顺序和维度进行拼接，除了拼接维度外，张量必须具有相同的形状。&lt;/p&gt;&#xA;&lt;p&gt;可用于特征维度的拓展，加入新的特征。&lt;/p&gt;&#xA;&lt;h3 id=&#34;5-unsqueeze&#34;&gt;5. &lt;code&gt;unsqueeze()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&#xD;&#xA;&lt;a href=&#34;https://docs.pytorch.org/docs/stable/generated/torch.unsqueeze.html#torch.unsqueeze&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;torch.unsqueeze&lt;/a&gt;&#xD;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;torch.unsqueeze(&lt;em&gt;input&lt;/em&gt;, &lt;em&gt;dim&lt;/em&gt;) → Tensor&lt;/p&gt;&#xA;&lt;p&gt;为张量插入一个新的&lt;code&gt;size&lt;/code&gt;为1的维度。用于升维。配合&lt;code&gt;expand()&lt;/code&gt;食用更佳。&lt;/p&gt;&#xA;&lt;h3 id=&#34;6-expand&#34;&gt;6. &lt;code&gt;expand()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&#xD;&#xA;&lt;a href=&#34;https://docs.pytorch.org/docs/stable/generated/torch.Tensor.expand.html#torch.Tensor.expand&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;torch.Tensor.expand&lt;/a&gt;&#xD;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;这个只有张量方法，没有函数。&lt;/p&gt;</description>
    </item>
    <item>
      <title>用于搭建神经网络的函数</title>
      <link>https://liubaoshuai1402.github.io/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch2/</link>
      <pubDate>Mon, 19 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch2/</guid>
      <description>&lt;h1 id=&#34;用于搭建神经网络的函数&#34;&gt;用于搭建神经网络的函数&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;此处记录常见的神经网络函数，排名不分先后。&lt;/p&gt;&#xA;&lt;h2 id=&#34;全连接层&#34;&gt;全连接层&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-nnlinear&#34;&gt;1. &lt;code&gt;nn.Linear()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;对输入数据施加一个仿射线性变换，一般使用指定两个参数，是输入矩阵和输出矩阵的最高维的&lt;code&gt;size&lt;/code&gt;。（因为最高维一般是特征维度，这个函数就是用来控制特征维度&lt;code&gt;size&lt;/code&gt;大小的）&lt;/p&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/%E5%9B%BE%E5%8D%B7%E7%A7%AF.png&#34; style=&#34;zoom:50%;&#34; /&gt;&#xD;&#xA;&lt;p&gt;这里是CGCNN的图卷积操作公式，这里的W（权重），b（偏置）其实全连接层决定的。看到这样的写法就要明白其实是经历了一个全连接层。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;total_gated_fea = self.fc_full(total_nbr_fea)&#xD;&#xA;        &#xD;&#xA;total_gated_fea = self.bn1(total_gated_fea.view(&#xD;&#xA;&#x9;-1, self.atom_fea_len*2)).view(N, M, self.atom_fea_len*2)&#xD;&#xA;nbr_filter, nbr_core = total_gated_fea.chunk(2, dim=2)&#xD;&#xA;nbr_filter = self.sigmoid(nbr_filter)&#xD;&#xA;nbr_core = self.softplus1(nbr_core)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;对应代码就是进过全连接层后，（再进行批标准化，chunk分割，这些公式里没有体现），然后施加$\sigma$函数和激活函数（g）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;激活函数&#34;&gt;激活函数&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-nnrelu&#34;&gt;1. &lt;code&gt;nn.ReLU()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;这个激活函数不用指定输入输出特征的维度，它只是把所有特征变为非负，对于正值保留原始值，对于负值则转化为0。&lt;/p&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/ReLU.png&#34;/&gt;&#xD;&#xA;&lt;h3 id=&#34;2-nnsoftmax&#34;&gt;2. &lt;code&gt;nn.Softmax()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;对一个n维的张量施加Softmax()函数，使得其沿某个维度的元素值的和为1。所以接受一个&lt;code&gt;dim&lt;/code&gt;参数来指定维度。&#xA;&lt;/p&gt;&#xA;$$&#xD;&#xA;\mathrm{Softmax}(x_i)=\frac{\mathrm{exp}(x_i)}{\sum_{j}\mathrm{exp}(x_j)}&#xD;&#xA;$$&lt;p&gt;&#xA;这里简单插入一下Pytorch中有关&lt;code&gt;dim&lt;/code&gt;的实践。&lt;/p&gt;&#xA;&lt;p&gt;比如说一个张量的size是(4,2,3)，那么他的dim=0指的是4，dim=1指的是2，dim=2指的是3。&lt;/p&gt;&#xA;&lt;p&gt;比如说对于这个张量，我有个和Pytorch相反的习惯，我习惯先看每行有多少个元素，是3。我就误以为它的dim=0对应的是3。&lt;/p&gt;&#xA;&lt;p&gt;其实不然，深度学习中，dim最大值对应维度的size，往往对应样本的特征数。&lt;/p&gt;&#xA;&lt;p&gt;一个简单的二维的深度学习的输入张量的size一般是这样的：(batch_size,features)。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([[[0.3299, 0.4336, 0.2365],&#xD;&#xA;         [0.0695, 0.0668, 0.8638]],&#xD;&#xA;&#xD;&#xA;        [[0.8114, 0.1116, 0.0770],&#xD;&#xA;         [0.3142, 0.1086, 0.5772]],&#xD;&#xA;&#xD;&#xA;        [[0.3178, 0.4508, 0.2315],&#xD;&#xA;         [0.1620, 0.2610, 0.5770]],&#xD;&#xA;&#xD;&#xA;        [[0.4454, 0.4082, 0.1464],&#xD;&#xA;         [0.2974, 0.5297, 0.1729]]])&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;3-nnlogsoftmax&#34;&gt;3. &lt;code&gt;nn.LogSoftmax()&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;对一个n维的张量施加log(Softmax())函数，通常用于获取对数概率，并与损失函数&lt;code&gt;nn.NLLLoss()&lt;/code&gt;一起使用&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python中的文件操作</title>
      <link>https://liubaoshuai1402.github.io/%E4%BB%A3%E7%A0%81/fileoperations/</link>
      <pubDate>Sun, 18 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E4%BB%A3%E7%A0%81/fileoperations/</guid>
      <description>&lt;h1 id=&#34;python中的文件操作&#34;&gt;Python中的文件操作&lt;/h1&gt;&#xA;&lt;h3 id=&#34;获取当前路径&#34;&gt;获取当前路径&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;os.getcwd()&lt;/code&gt;可以返回当前工作目录的绝对路径。cwd可以理解成current work directory。&lt;/p&gt;&#xA;&lt;h3 id=&#34;创建多个用于vasp计算的文件夹&#34;&gt;创建多个用于VASP计算的文件夹&lt;/h3&gt;&#xA;&lt;p&gt;任务：假设你要对多个相似的结构进行计算，即他们所需的INCAR、KPOINTS、POTCAR、vasp.pbs（提交任务的脚本）是一样的。&lt;/p&gt;&#xA;&lt;p&gt;INCAR、KPOINTS、POTCAR、vasp.pbs在当前文件夹中&lt;/p&gt;&#xA;&lt;p&gt;我们要在当前文件夹中创建一个名为&lt;code&gt;&#39;distorted&#39;&lt;/code&gt;的文件夹，并在其中创建若干个计算文件夹。&lt;/p&gt;&#xA;&lt;p&gt;代码如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os&#xD;&#xA;import shutil&#xD;&#xA;&#xD;&#xA;#先记录下四个计算文件的路径&#xD;&#xA;cwd = os.getcwd()&#xD;&#xA;INCARPath = os.path.join(cwd,&#39;INCAR&#39;)&#xD;&#xA;KPOINTSPath = os.path.join(cwd,&#39;KPOINTS&#39;)&#xD;&#xA;POTCARPath = os.path.join(cwd,&#39;POTCAR&#39;)&#xD;&#xA;PBSPath = os.path.join(cwd,&#39;vasp.pbs&#39;)&#xD;&#xA;#创建一个总路径，用于存放计算文件夹&#xD;&#xA;os.makedirs(&#39;distorted&#39;)&#xD;&#xA;path = os.path.join(cwd,&#39;distorted&#39;)&#xD;&#xA;#通过循环，在distorted路径下创建若干个计算文件夹，并把计算文件复制过去&#xD;&#xA;for i in range(10):&#xD;&#xA;    CalPath = os.path.join(path,&#39;{:03d}&#39;.format(i))&#xD;&#xA;    os.makedirs(CalPath)&#xD;&#xA;    shutil.copy(INCARPath,CalPath)&#xD;&#xA;    shutil.copy(KPOINTSPath,CalPath)&#xD;&#xA;    shutil.copy(POTCARPath,CalPath)&#xD;&#xA;    shutil.copy(PBSPath,CalPath)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>花朵分类</title>
      <link>https://liubaoshuai1402.github.io/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch1/</link>
      <pubDate>Sun, 18 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch1/</guid>
      <description>&lt;h1 id=&#34;花朵分类&#34;&gt;花朵分类&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;本文主要借助torchvision软件包，简单梳理一下深度学习代码的基本框架。&lt;/p&gt;&#xA;&lt;h2 id=&#34;数据集加载&#34;&gt;数据集加载&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#假设当前工作路径下，存放着一个名为&#39;flower_data&#39;的文件夹，里面存放着训练集和验证集的图片&#xD;&#xA;#用os.path.join()来一级级得获取路径&#xD;&#xA;data_dir = os.path.join(os.getcwd(),&#39;flower_data&#39;)&#xD;&#xA;train_dir = os.path.join(data_dir, &#39;train&#39;)&#xD;&#xA;valid_dir = os.path.join(data_dir, &#39;valid&#39;)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Define batch size&#xD;&#xA;batch_size = 32&#xD;&#xA;&#xD;&#xA;# Define transforms for the training and validation sets&#xD;&#xA;normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406],&#xD;&#xA;                                 std=[0.229, 0.224, 0.225])&#xD;&#xA;&#xD;&#xA;#定义对数据预处理的组合，比如旋转图片、改变尺寸等等，让模型有更强的稳定性&#xD;&#xA;train_data_transforms = transforms.Compose([&#xD;&#xA;        transforms.RandomResizedCrop(size=256, scale=(0.8, 1.0)),&#xD;&#xA;        transforms.RandomRotation(degrees=15),&#xD;&#xA;        transforms.ColorJitter(),&#xD;&#xA;        transforms.RandomHorizontalFlip(),&#xD;&#xA;        transforms.CenterCrop(size=224),&#xD;&#xA;        transforms.ToTensor(),&#xD;&#xA;        normalize,&#xD;&#xA;    ])&#xD;&#xA;&#xD;&#xA;validate_data_transforms = transforms.Compose([&#xD;&#xA;        transforms.Resize(256),&#xD;&#xA;        transforms.CenterCrop(224),&#xD;&#xA;        transforms.ToTensor(),&#xD;&#xA;        normalize,&#xD;&#xA;    ])&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#这里才真正的把图片加载成了二维数据。&#xD;&#xA;train_dataset = datasets.ImageFolder(&#xD;&#xA;    train_dir,&#xD;&#xA;    train_data_transforms)&#xD;&#xA;&#xD;&#xA;validate_dataset = datasets.ImageFolder(&#xD;&#xA;    valid_dir,&#xD;&#xA;    validate_data_transforms)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#做了那么多铺垫，其实就是为了把可用于训练的数据(二维数据)放到 DataLoader 里面&#xD;&#xA;train_loader = torch.utils.data.DataLoader(&#xD;&#xA;    train_dataset, batch_size=batch_size, shuffle=True,&#xD;&#xA;    num_workers=4)&#xD;&#xA;&#xD;&#xA;validate_loader = torch.utils.data.DataLoader(&#xD;&#xA;    validate_dataset, batch_size=batch_size, shuffle=True,&#xD;&#xA;    num_workers=4)&#xD;&#xA;&#xD;&#xA;data_loader = {}&#xD;&#xA;data_loader[&#39;train&#39;] = train_loader&#xD;&#xA;data_loader[&#39;valid&#39;] = validate_loader&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;batch_size&lt;/code&gt;，当训练数据很多时，一次性加载全部数据进行训练会是一种挑战。这时就需要用到批次训练。&lt;code&gt;batch_size&lt;/code&gt;即是一次训练中使用的数据量。注意这里的一次训练，不是指一epoch。只有遍历所有训练集后，才能叫做完成了一代训练。一代训练包含了诸多这样的一次训练。&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用rNEMD方法计算热导率的lammps输入文件</title>
      <link>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/thermal_conductivity_rnemd/</link>
      <pubDate>Fri, 16 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/thermal_conductivity_rnemd/</guid>
      <description>&lt;h1 id=&#34;使用rnemd方法计算热导率的lammps输入文件&#34;&gt;使用rNEMD方法计算热导率的LAMMPS输入文件&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&#xD;&#xA;&lt;a href=&#34;https://doi.org/10.1063/1.473271&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;rNEMD方法&lt;/a&gt;&#xD;&#xA;，又叫MP方法，计算材料热导率。&lt;/p&gt;&#xA;&lt;p&gt;LAMMPS官方提供了计算脚本，但是使用的单位却是&lt;code&gt;lj&lt;/code&gt;单位制，非常不实用，这里是我自己写的&lt;code&gt;metal&lt;/code&gt;单位制下的脚本。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;in-file&#34;&gt;in file&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# sample LAMMPS input script for thermal conductivity of liquid LJ&#xD;&#xA;# Muller-Plathe method via fix thermal_conductivity&#xD;&#xA;&#xD;&#xA;# settings      temperature, kB and timestep&#xD;&#xA;&#xD;&#xA;variable        t equal 1500&#xD;&#xA;variable        k equal 8.6173e-5 &#xD;&#xA;variable        dt equal 0.0005&#xD;&#xA;&#xD;&#xA;# convert from LAMMPS metal units to SI&#xD;&#xA;variable        eV2J equal 1.6022e-19          #energy convert&#xD;&#xA;variable        A2m equal 1.0e-10           #distance convert&#xD;&#xA;variable        ps2s equal 1.0e-12          #time convert  &#xD;&#xA;variable        convert equal ${eV2J}/${ps2s}/${A2m}          &#xD;&#xA;&#xD;&#xA;# setup problem&#xD;&#xA;&#xD;&#xA;units           metal&#xD;&#xA;atom_style      atomic&#xD;&#xA;atom_modify     map yes&#xD;&#xA;newton          on&#xD;&#xA;read_data       ./333&#xD;&#xA;pair_style      mace no_domain_decomposition&#xD;&#xA;pair_coeff * *  /home-ssd/Users/nsgm_lbs/train/MACE_model/MACE_model_run-123_stagetwo.model-lammps.pt O Zr Y H&#xD;&#xA;neighbor        1.0 bin&#xD;&#xA;neigh_modify    every 500 delay 0 check no&#xD;&#xA;minimize        1e-5 1e-7 1000 1000&#xD;&#xA;timestep        ${dt}&#xD;&#xA;velocity        all create $t 87287&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 1st equilibration run&#xD;&#xA;reset_timestep  0&#xD;&#xA;fix             1 all npt temp $t $t 0.05 iso 0 0 0.5&#xD;&#xA;thermo_style    custom step temp pe etotal enthalpy lx ly lz vol press&#xD;&#xA;thermo          100&#xD;&#xA;run             5000&#xD;&#xA;unfix           1&#xD;&#xA;velocity        all scale $t&#xD;&#xA;fix             1 all nvt temp $t $t 0.05&#xD;&#xA;run             5000&#xD;&#xA;unfix           1&#xD;&#xA;&#xD;&#xA;# 2nd equilibration run&#xD;&#xA;compute         ke all ke/atom&#xD;&#xA;variable        temp atom c_ke/1.5/${k}&#xD;&#xA;&#xD;&#xA;fix             1 all nve&#xD;&#xA;&#xD;&#xA;compute         layers all chunk/atom bin/1d z lower 0.05 units reduced&#xD;&#xA;fix             2 all ave/chunk 10 100 1000 layers v_temp file profile.mp&#xD;&#xA;fix             3 all thermal/conductivity 100 z 20&#xD;&#xA;&#xD;&#xA;variable        tdiff equal f_2[11][3]-f_2[1][3]&#xD;&#xA;thermo_style    custom step temp epair etotal f_3 v_tdiff&#xD;&#xA;thermo_modify   colname f_3 E_delta colname v_tdiff dTemp_step&#xD;&#xA;&#xD;&#xA;thermo          1000&#xD;&#xA;run             20000&#xD;&#xA;&#xD;&#xA;# thermal conductivity calculation&#xD;&#xA;# reset fix thermal/conductivity to zero energy accumulation&#xD;&#xA;fix             3 all thermal/conductivity 100 z 20&#xD;&#xA;variable        start_time equal time&#xD;&#xA;variable        kappa equal (f_3/(time-${start_time})/(lx*ly)/2.0)*(lz/2.0)/f_ave&#xD;&#xA;fix             ave all ave/time 1 1 1000 v_tdiff ave running&#xD;&#xA;thermo_style    custom step temp epair etotal f_3 v_tdiff f_ave&#xD;&#xA;thermo_modify   colname f_3 E_delta colname v_tdiff dTemp_step colname f_ave dTemp&#xD;&#xA;run             20000&#xD;&#xA;print           &amp;quot;Running average thermal conductivity units metal: $(v_kappa)&amp;quot;&#xD;&#xA;variable        tc  equal ${kappa}*${convert}&#xD;&#xA;print           &amp;quot;Running average thermal conductivity units SI: $(v_tc:%.2f)&amp;quot;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>如何构建训练集用于训练机器学习势</title>
      <link>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/mace1/</link>
      <pubDate>Fri, 16 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/mace1/</guid>
      <description>&lt;h1 id=&#34;如何构建训练集用于训练机器学习势&#34;&gt;如何构建训练集用于训练机器学习势&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;本文将介绍如何构建一个训练集，用于训练MACE势以及DP势。需要提前利用AIMD获取DFT数据集。这里的AIMD软件是VASP。&lt;/p&gt;&#xA;&lt;p&gt;软件：ASE、DeepMD-Kit&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;构建mace势的训练集&#34;&gt;构建MACE势的训练集&lt;/h2&gt;&#xA;&lt;p&gt;MACE接受的训练集非常简单，一个&lt;code&gt;xyz&lt;/code&gt;文件，包含了各种构型和它们对应的DFT数据标签，以及单原子的DFT数据，需要额外的标签&lt;code&gt;config_type=IsolatedAtom&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;顺带一提，ASE可以输出一种所谓的&#xD;&#xA;&lt;a href=&#34;https://wiki.fysik.dtu.dk/ase/ase/io/formatoptions.html#extxyz&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;Extended XYZ format&lt;/a&gt;&#xD;&#xA;，会把各种各样的信息（有点类似OVITO中的全局信息），放到&lt;code&gt;xyz&lt;/code&gt;文件的第二行。这一行会很长很长。MACE所采用的训练集输入格式就是它。&lt;/p&gt;&#xA;&lt;p&gt;假设我们要构建水分子的MACE势，当前所处的路径下，有两个文件夹。&lt;/p&gt;&#xA;&lt;p&gt;一个名为&lt;code&gt;H2O&lt;/code&gt;的文件夹，里面存放着进行第一性原理分子动力学后得到的&lt;code&gt;OUTCAR.tar.gz&lt;/code&gt;文件。路径为&lt;code&gt;H2O/OUTCAR.tar.gz&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;一个名为&lt;code&gt;IsolatedAtoms&lt;/code&gt;的文件夹，里面存放着涉及元素（这里是H、O）的单原子的单点能计算（ISPIN=2）。路径分别为&lt;code&gt;IsolatedAtoms/H/OUTCAR.tar.gz&lt;/code&gt;和&lt;code&gt;IsolatedAtoms/O/OUTCAR.tar.gz&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;代码展示&#34;&gt;代码展示&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ase.io import read,write&#xD;&#xA;import random&#xD;&#xA;&#xD;&#xA;#定义一个简单的函数用于打标签,这里可以自由更改标签的名字&#xD;&#xA;def addlabel(configs,energy_label=&#39;energy_dft&#39;,forces_label=&#39;forces_dft&#39;,stress_label=&#39;stress_dft&#39;,is_isolated=False):&#xD;&#xA;    if is_isolated == False:&#xD;&#xA;        for at in configs:&#xD;&#xA;            at.info[energy_label] = at.get_potential_energy(force_consistent=True)&#xD;&#xA;            at.arrays[forces_label] = at.get_forces()&#xD;&#xA;            at.info[stress_label] = at.get_stress(voigt=True)&#xD;&#xA;    if is_isolated == True:&#xD;&#xA;        for at in configs:&#xD;&#xA;            at.info[&#39;config_type&#39;] = &#39;IsolatedAtom&#39;&#xD;&#xA;            at.info[energy_label] = at.get_potential_energy(force_consistent=True)&#xD;&#xA;            at.arrays[forces_label] = at.get_forces()&#xD;&#xA;            at.info[stress_label] = at.get_stress(voigt=True)&#xD;&#xA;&#xD;&#xA;#read()函数，这里，第一个参数是所读文件路径，第二个参数是切片slice&#xD;&#xA;IsolatedH = read(&#39;IsolatedAtoms/H/OUTCAR.tar.gz&#39;,&#39;:&#39;)&#xD;&#xA;IsolatedO = read(&#39;IsolatedAtoms/O/OUTCAR.tar.gz&#39;,&#39;:&#39;)&#xD;&#xA;IsolatedAtoms = IsolatedH + IsolatedO&#xD;&#xA;addlabel(configs=IsolatedAtoms,is_isolated=True)&#xD;&#xA;&#xD;&#xA;#这里的slice的意思是从第一个结构开始到最后一个结构，每100个结构取一个&#xD;&#xA;db = read(&#39;H2O/OUTCAR.tar.gz&#39;,&#39;::100&#39;)&#xD;&#xA;addlabel(configs=db)&#xD;&#xA;&#xD;&#xA;#打乱训练集，这对训练非常重要&#xD;&#xA;random.seed(42)&#xD;&#xA;random.shuffle(db)&#xD;&#xA;&#xD;&#xA;#将打过标签的数据集合并&#xD;&#xA;db = db + IsolatedAtoms&#xD;&#xA;write(&#39;trainset.xyz&#39;,db)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这里有趣的一点是，为什么对于单个结构的&lt;code&gt;OUTCAR&lt;/code&gt;，也要进行切片：&lt;code&gt;IsolatedH = read(&#39;IsolatedAtoms/H/OUTCAR.tar.gz&#39;,&#39;:&#39;)&lt;/code&gt;，而不是&lt;code&gt;IsolatedH = read(&#39;IsolatedAtoms/H/OUTCAR.tar.gz&#39;)&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>机器学习势MACE的输入文件</title>
      <link>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/mace2/</link>
      <pubDate>Fri, 16 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8A%BF/mace2/</guid>
      <description>&lt;h1 id=&#34;机器学习势mace的输入文件&#34;&gt;机器学习势MACE的输入文件&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;不同MACE版本的参数设置会有一定的调查，注意查看自己的MACE版本。这里是0.3.13版本&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;在超算上用slurm提交python任务&#34;&gt;在超算上用slurm提交python任务&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash&#xD;&#xA;#SBATCH -o job.%j.out&#xD;&#xA;#SBATCH -J lmp_job_gpu&#xD;&#xA;#SBATCH --partition=gpu        &#xD;&#xA;#SBATCH -N 1                    &#xD;&#xA;#SBATCH -G 1&#xD;&#xA;#SBATCH --gres=gpu:1&#xD;&#xA;#SBATCH --exclusive&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;export PATH=/home-ssd/Users/nsgm_zcx/openmpi-5.0.5/build/bin:$PATH&#xD;&#xA;export LD_LIBRARY_PATH=/home-ssd/Users/nsgm_zcx/openmpi-5.0.5/build/lib:$LD_LIBRARY_PATH&#xD;&#xA;export PATH=/home-ssd/Users/nsgm_zcx/lammps-develop/build-mliap:$PATH&#xD;&#xA;&#xD;&#xA;source /home-ssd/Users/nsgm_zcx/miniconda3/etc/profile.d/conda.sh&#xD;&#xA;conda activate cuda&#xD;&#xA;&#xD;&#xA;mace_run_train --config parameters.yaml&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;前面几行是为了激活lammps和openmpi，在这里没啥用。&lt;/p&gt;&#xA;&lt;p&gt;重要的是要在sh脚本里激活conda，然后用&lt;code&gt;mace_run_train&lt;/code&gt;命令行脚本来提交训练任务。&lt;/p&gt;&#xA;&lt;p&gt;用&lt;code&gt;--config&lt;/code&gt;参数和一个yaml文件来提供训练参数。&lt;/p&gt;&#xA;&lt;p&gt;以下是&lt;code&gt;parameters.yaml&lt;/code&gt;的内容&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: YSZH_MACE_model&#xD;&#xA;seed: 123&#xD;&#xA;device: cuda&#xD;&#xA;train_file: train.xyz&#xD;&#xA;valid_fraction: 0.2&#xD;&#xA;test_file: test.xyz&#xD;&#xA;compute_forces: True&#xD;&#xA;compute_stress: True&#xD;&#xA;energy_key: energy_vasp&#xD;&#xA;forces_key: forces_vasp&#xD;&#xA;stress_key: stress_vasp&#xD;&#xA;E0s: &#39;isolated&#39;&#xD;&#xA;hidden_irreps: &#39;64x0e + 64x1o&#39;&#xD;&#xA;r_max: 4.0&#xD;&#xA;batch_size: 20&#xD;&#xA;max_num_epochs: 600&#xD;&#xA;swa: True&#xD;&#xA;start_swa: 480&#xD;&#xA;ema: True&#xD;&#xA;ema_decay: 0.99&#xD;&#xA;default_dtype: float32&#xD;&#xA;lr: 0.01&#xD;&#xA;scaling: rms_forces_scaling&#xD;&#xA;multiheads_finetuning: False&#xD;&#xA;enable_cueq: True&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;要使用&lt;code&gt;mliap&lt;/code&gt;，就必须打开参数&lt;code&gt;enable_cueq: True&lt;/code&gt;，并确保python环境中安装了&lt;code&gt;cuEquivariance&lt;/code&gt;和&lt;code&gt;cupy&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>均方位移（MSD）-OVITO</title>
      <link>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/msd_ovito/</link>
      <pubDate>Tue, 13 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/msd_ovito/</guid>
      <description>&lt;h1 id=&#34;均方位移msd计算-by-ovito&#34;&gt;均方位移（MSD）计算 by OVITO&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&#xD;&#xA;&lt;a href=&#34;https://docs.ovito.org/python/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;OVITO Python Reference — OVITO Python Reference 3.12.3 documentation&lt;/a&gt;&#xD;&#xA; 是一个开源且功能强大的分子动力学后处理软件包。&lt;/p&gt;&#xA;&lt;p&gt;本文将介绍如何利用 OVITO python module 计算某类元素原子在一段轨迹内的均方位移。&lt;/p&gt;&#xA;&lt;p&gt;适用于无机非晶体，其他体系慎用。&lt;/p&gt;&#xA;&lt;p&gt;软件：OVITO、matplotlib、numpy&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ovito版&#34;&gt;OVITO版&lt;/h2&gt;&#xA;&lt;h3 id=&#34;代码展示&#34;&gt;代码展示&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ovito.io import import_file, export_file&#xD;&#xA;from ovito.modifiers import CalculateDisplacementsModifier&#xD;&#xA;from ovito.modifiers import SelectTypeModifier,InvertSelectionModifier,DeleteSelectedModifier,ExpressionSelectionModifier&#xD;&#xA;import numpy as np&#xD;&#xA;import matplotlib.pyplot as plt&#xD;&#xA;&#xD;&#xA;#万物起源 import_file ，导入一段要计算的轨迹&#xD;&#xA;pipeline = import_file(&amp;quot;1.dump&amp;quot;)&#xD;&#xA;&#xD;&#xA;#添加 SelectTypeModifier 修饰器&#xD;&#xA;#设置参数 property = &#39;Particle Type&#39; 指定选择的类型（这里我们指定的是原子类型）&#xD;&#xA;#设置参数 types = {4} 指定具体的原子类型，这里是这个轨迹中的 4 原子（这个值要根据自己的体系修改），这里用数字代表原子是因为我使用的lammps的输出风格没有记录原子的元素符号，如果你的轨迹里记录的是 元素符号 信息，比如说 VASP 输出的 XDATCAR，则需要用类似于 types = {&amp;quot;H&amp;quot;} 的写法&#xD;&#xA;pipeline.modifiers.append(SelectTypeModifier(property = &#39;Particle Type&#39;, types = {4}))&#xD;&#xA;&#xD;&#xA;#添加 InvertSelectionModifier 修饰器，进行原子反选，为剔除不需要计算的原子做准备&#xD;&#xA;pipeline.modifiers.append(InvertSelectionModifier())    &#xD;&#xA;&#xD;&#xA;#添加 DeleteSelectedModifier 修饰器，删除上一行代码反选的原子，留下需要计算的原子&#xD;&#xA;pipeline.modifiers.append(DeleteSelectedModifier(operate_on= {&#39;particles&#39;}))                    &#xD;&#xA;&#xD;&#xA;#添加 CalculateDisplacementsModifier 修饰器，指定计算 MSD 的参考结构，这里 reference_frame = 0 代表初始结构是参考结构&#xD;&#xA;reference_frame = 0&#xD;&#xA;pipeline.modifiers.append(CalculateDisplacementsModifier(reference_frame=0))    #a subclass of ovito.pipeline.ReferenceConfigurationModifier&#xD;&#xA;&#xD;&#xA;#自定义一个修饰器函数，用于将 per-particle displacement 转化为相应元素的均方位移&#xD;&#xA;#本文的 OVITO小知识 将简单介绍自定义修饰器是如何工作的&#xD;&#xA;def calculate_msd(frame, data):&#xD;&#xA;    &#xD;&#xA;&#x9;#用一个变量 displacement_magnitudes 记录 data.particles[&#39;Displacement Magnitude&#39;]，简化代码&#xD;&#xA;&#x9;displacement_magnitudes = data.particles[&#39;Displacement Magnitude&#39;]&#xD;&#xA;&#x9;#计算 MSD （将所有原子位移的平方加和然后求平均），OVITO 的数据可以直接和 numpy 交互，nice&#xD;&#xA;&#x9;msd = np.sum(displacement_magnitudes ** 2) / len(displacement_magnitudes)           &#xD;&#xA;&#x9;#把计算的 MSD 传递给 data (DataCollection类)&#xD;&#xA;&#x9;data.attributes[&amp;quot;MSD&amp;quot;] = msd &#xD;&#xA;    &#xD;&#xA;#添加自定义 calculate_msd 修饰器&#xD;&#xA;pipeline.modifiers.append(calculate_msd)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#计算 Pipeline, 得到time vs MSD的数据&#xD;&#xA;table = []     #用于存放数据，time vs MSD&#xD;&#xA;&#xD;&#xA;for frame,data in enumerate(pipeline.frames):&#xD;&#xA;&#x9;if frame &amp;gt;= reference_frame:&#xD;&#xA;&#x9;&#x9;#这里的 *10 一定要根据自己的计算调整，我的轨迹在lammps计算设置：时间步是0.5fs，每20步输出一帧，所以轨迹中每帧其实经历了10fs，所以乘以10&#xD;&#xA;&#x9;&#x9;#我们 time vs MSD 的x横坐标单位是fs，也可以是别的，自己调整&#xD;&#xA;&#x9;&#x9;time = (frame-reference_frame)*10                 &#xD;&#xA;&#x9;&#x9;table.append([time,data.attributes[&#39;MSD&#39;]])&#xD;&#xA;&#xD;&#xA;#.csv文件还是比较高级的，比纯txt好些，delimiter 指定间隔符为 &amp;quot;,&amp;quot; ,这样方便直接excel打开&#xD;&#xA;np.savetxt(&amp;quot;msd_data.csv&amp;quot;,table,delimiter=&amp;quot;,&amp;quot;)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;ovito小知识&#34;&gt;OVITO小知识&lt;/h2&gt;&#xA;&lt;p&gt;受限于Python基础和时间精力的限制，以下内容皆为我个人的有限理解，未能严格考究，仅供参考。&lt;/p&gt;</description>
    </item>
    <item>
      <title>稍微深入一些Python中的类（class）</title>
      <link>https://liubaoshuai1402.github.io/%E4%BB%A3%E7%A0%81/class_in_python/</link>
      <pubDate>Tue, 13 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E4%BB%A3%E7%A0%81/class_in_python/</guid>
      <description>&lt;h1 id=&#34;稍微深入一些python中的类class&#34;&gt;稍微深入一些Python中的类（class）&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;**类（class）**在python代码中几乎无处不在，但在近日的学习中发现，我对它真是了解甚少，甚至基础结构都不能熟稔于心，故开此笔记认真学习。和我一起重新认识一下它吧。&lt;/p&gt;&#xA;&lt;h2 id=&#34;一个简单的类&#34;&gt;一个简单的类&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#code 1&#xD;&#xA;class Dog:&#xD;&#xA;    # 类属性&#xD;&#xA;    species = &amp;quot;Dog&amp;quot;&#xD;&#xA;    # 初始化方法&#xD;&#xA;    def __init__(self, name, age):&#xD;&#xA;        self.name = name&#xD;&#xA;        self.age = age&#xD;&#xA;    # 实例方法&#xD;&#xA;    def bark(self):&#xD;&#xA;        return print(&amp;quot;旺旺&amp;quot;)&#xD;&#xA;&#xD;&#xA;print(mydog.species)&#xD;&#xA;print(mydog.name,mydog.age)&#xD;&#xA;mydog.bark()&#xD;&#xA;&#xD;&#xA;#输出为：&#xD;&#xA;#Dog&#xD;&#xA;#doudou 2&#xD;&#xA;#旺旺&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;strong&gt;类&lt;/strong&gt;是一种对数据进行计算操作的蓝图，离不开&lt;strong&gt;属性&lt;/strong&gt;和&lt;strong&gt;方法&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;code 1中，我们定义了一个 Dog 类，并对它进行了实例化，生成了一个对象。&lt;/p&gt;&#xA;&lt;p&gt;这个类的结构，很简单。&lt;/p&gt;&#xA;&lt;p&gt;首先是放在第一部分的&lt;strong&gt;类属性&lt;/strong&gt;。&lt;strong&gt;类属性&lt;/strong&gt;是&lt;strong&gt;直接在类中定义变量&lt;/strong&gt;。所有通过这个类生成的对象都具有这些属性。&lt;/p&gt;&#xA;&lt;p&gt;然后是放在第二部分的诸多方法，其实就是一个个的函数。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def __init__(self, name, age):&#xD;&#xA;        self.name = name&#xD;&#xA;        self.age = age&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;_init_&lt;/code&gt;方法叫&lt;strong&gt;初始化方法&lt;/strong&gt;，是&lt;strong&gt;魔法方法&lt;/strong&gt;的一种。让实例初始化时就具有&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;age&lt;/code&gt;属性和相应的值。具体表现为&lt;code&gt;mydog = Dog(&amp;quot;doudou&amp;quot;,2)&lt;/code&gt;，这个类在初始化时就&lt;strong&gt;需要两个参数&lt;/strong&gt;才能转变为实例。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;python中所有的实例方法，包括&lt;code&gt;__init__&lt;/code&gt;方法，第一个参数都必须是&lt;code&gt;self&lt;/code&gt;，用于区别&lt;strong&gt;普通函数&lt;/strong&gt;和&lt;strong&gt;方法&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;默认值&lt;/strong&gt;，在定义方法的时候，可以传入默认值，这可以保证在不传入参数时，也能生成一个默认实例。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def __init__(self, name=&amp;quot;小卡拉米&amp;quot;, age=5):&#xD;&#xA;        self.name = name&#xD;&#xA;        self.age = age&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这样的&lt;code&gt;__init__&lt;/code&gt;方法就保证了，即使狗主人忘记了填写信息，&lt;code&gt;mydog = Dog()&lt;/code&gt;也能正常工作，但默认的狗狗是&lt;strong&gt;小卡拉米&lt;/strong&gt;，还是应该记得为自己的狗狗正确填写信息呦。（对于其他实例方法也适用）&lt;/p&gt;</description>
    </item>
    <item>
      <title>径向分布函数（RDF）-OVITO</title>
      <link>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/rdf_ovito/</link>
      <pubDate>Mon, 12 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/rdf_ovito/</guid>
      <description>&lt;h1 id=&#34;径向分布函数rdf计算-by-ovito&#34;&gt;径向分布函数（RDF）计算 by OVITO&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&#xD;&#xA;&lt;a href=&#34;https://docs.ovito.org/python/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;OVITO Python Reference — OVITO Python Reference 3.12.3 documentation&lt;/a&gt;&#xD;&#xA; 是一个开源且功能强大的分子动力学后处理软件包。&lt;/p&gt;&#xA;&lt;p&gt;本文将介绍如何利用 OVITO python module 计算单个结构以及一段轨迹（多个结构）内的径向分布函数。&lt;/p&gt;&#xA;&lt;p&gt;适用于无机非晶体，其他体系慎用。&lt;/p&gt;&#xA;&lt;p&gt;软件：OVITO、matplotlib、numpy&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-partial-rdfs-of-a-single-crystal-structure&#34;&gt;The partial RDFs of a single crystal structure&lt;/h2&gt;&#xA;&lt;h3 id=&#34;代码展示&#34;&gt;代码展示&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#这段代码用于计算 RDF by OVITO&#xA;from ovito.io import import_file&#xA;from ovito.modifiers import CoordinationAnalysisModifier&#xA;import numpy as np&#xA;&#xA;#导入一个氧化锆（ZrO2）的cif文件，所有OVITO支持的输入文件格式都可以（确保这个.py文件的路径下有这样一个cif文件，也可以稍微修改指定结构路径）&#xA;pipeline = import_file(&amp;quot;ZrO.cif&amp;quot;)&#xA;&#xA;#施加一个名叫 CoordinationAnalysisModifier 的修饰器，cutoff用于控制截断半径，number_of_bins用于控制网格细分度（大小100-1000内都可以试试）&#xA;pipeline.modifiers.append(CoordinationAnalysisModifier(cutoff = 5.0, number_of_bins = 500,partial=True))&#xA;&#xA;#进行计算&#xA;rdf_table = pipeline.compute().tables[&#39;coordination-rdf&#39;]&#xA;&#xA;#得到用于画图的横纵坐标，默认第一列是x轴数据，其余列是y轴数据&#xA;total_rdf = rdf_table.xy()&#xA;&#xA;#记录total_rdf中y轴数据对应是什么类型的pair-wise&#xA;#这个例子中，输出为：&#xA;#g(r) for pair-wise type combination O-O:&#xA;#g(r) for pair-wise type combination O-Zr:&#xA;#g(r) for pair-wise type combination Zr-Zr:&#xA;#说明total_rdf是一个四列的数据，第一列是x轴坐标（其实是bin），第二列就是不同pair-wise的RDF数据，依次为 O-O,O-Zr,Zr-Zr&#xA;rdf_names = rdf_table.y.component_names&#xA;for component, name in enumerate(rdf_names):&#xA;    print(&amp;quot;g(r) for pair-wise type combination %s:&amp;quot; % name)&#xA;    &#xA;#将total_rdf保存为txt文件，用于后续画图&#xA;np.savetxt(&amp;quot;total_rdf.txt&amp;quot;, total_rdf)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#这段代码用于绘图&#xA;import numpy as np&#xA;import matplotlib.pyplot as plt&#xA;&#xA;rdf_table = np.loadtxt(&#39;total_rdf.txt&#39;)&#xA;&#xA;#g(r) for pair-wise type combination O-O:&#xA;#g(r) for pair-wise type combination O-Zr:&#xA;#g(r) for pair-wise type combination Zr-Zr:&#xA;&#xA;#这里取的是 total_rdf.txt 中的第一列（对应[:,0]）和第三列（对应[:,2]），所以绘制的是 Zr-O pair-wise的partial RDF&#xA;plt.plot(rdf_table[:,0], rdf_table[:,2])&#xA;&#xA;#matplotlib的常规设置，问问万能的小迪老师吧&#xA;title_font = {&#39;fontsize&#39;: 24, &#39;fontfamily&#39;: &#39;Times New Roman&#39;}&#xA;xlabel_font = {&#39;fontsize&#39;: 22, &#39;fontfamily&#39;: &#39;Times New Roman&#39;}&#xA;ylabel_font = {&#39;fontsize&#39;: 22, &#39;fontfamily&#39;: &#39;Times New Roman&#39;}&#xA;&#xA;plt.title(&amp;quot;RDF Zr-O&amp;quot;, fontdict=title_font,pad=8)&#xA;plt.xlabel(xlabel=&#39;distance r&#39;,fontdict=xlabel_font,loc=&#39;center&#39;,labelpad=8)&#xA;plt.ylabel(ylabel=&#39;g(r)&#39;,fontdict=ylabel_font,loc=&#39;center&#39;,labelpad=8)&#xA;plt.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16, direction=&#39;in&#39;)&#xA;&#xA;ax = plt.subplot()&#xA;&#xA;#因为只有一个静态结构，pair-wise的某些峰很高，所以这里的y轴坐标上限设置大一些，为200，可灵活改变&#xA;#x轴设置为6，稍大于截断半径cutoff即可，因为本身也只在截断半径以内统计&#xA;ax.set_ylim(0,200)&#xA;plt.xlim(0,6)&#xA;&#xA;fig = plt.gcf()&#xA;&#xA;fig.set_size_inches(1200/100, 800/100)&#xA;plt.savefig(&#39;output.png&#39;, dpi=100)&#xA;&#xA;plt.show()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;结果展示&#34;&gt;结果展示&lt;/h3&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/output.png&#34;/&gt;&#xA;&lt;h2 id=&#34;the-partial-rdfs-of-trajectories&#34;&gt;The partial RDFs of trajectories&lt;/h2&gt;&#xA;&lt;h3 id=&#34;代码展示-1&#34;&gt;代码展示&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#这段代码用于计算一定时间内（一段轨迹）的平均 RDFs&#xA;from ovito.io import import_file&#xA;from ovito.modifiers import CoordinationAnalysisModifier,TimeAveragingModifier&#xA;import numpy as np&#xA;&#xA;#读入轨迹文件，这里是利用 VASP 进行 AIMD 后得到的 XDATCAR 文件&#xA;pipeline = import_file(&amp;quot;XDATCAR&amp;quot;)&#xA;&#xA;#打印轨迹中的结构数&#xA;print(&amp;quot;Number of MD frames:&amp;quot;, pipeline.num_frames)&#xA;&#xA;#添加修饰器，与单个晶体结构相比，多了 TimeAveragingModifier 修饰器&#xA;pipeline.modifiers.append(CoordinationAnalysisModifier(cutoff = 5.0, number_of_bins = 500,partial=True))&#xA;pipeline.modifiers.append(TimeAveragingModifier(operate_on=&#39;table:coordination-rdf&#39;))&#xA;&#xA;#计算 RDFs 数据&#xA;total_rdf = pipeline.compute().tables[&#39;coordination-rdf[average]&#39;].xy()&#xA;&#xA;#记录pair-wise类型&#xA;rdf_names = pipeline.compute().tables[&#39;coordination-rdf[average]&#39;].y.component_names&#xA;for name in rdf_names:&#xA;    print(&amp;quot;g(r) for pair-wise type combination %s:&amp;quot; % name)&#xA;&#xA;#输出数据，用于后续绘图，不再重复&#xA;np.savetxt(&#39;rdf.txt&#39;, total_rdf, delimiter=&#39;\t&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;ovito小知识&#34;&gt;OVITO小知识&lt;/h2&gt;&#xA;&lt;p&gt;受限于Python基础和时间精力的限制，以下内容皆为我个人的有限理解，未能严格考究，仅供参考。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://liubaoshuai1402.github.io/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/search/</guid>
      <description></description>
    </item>
    <item>
      <title></title>
      <link>https://liubaoshuai1402.github.io/%E7%94%A8%E5%BF%83%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%A7%A6%E7%9A%87%E5%B2%9B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E7%94%A8%E5%BF%83%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E7%A7%A6%E7%9A%87%E5%B2%9B/</guid>
      <description>&lt;h1 id=&#34;目的地&#34;&gt;目的地&lt;/h1&gt;&#xA;&lt;h3 id=&#34;北戴河湿地公园&#34;&gt;北戴河湿地公园&lt;/h3&gt;</description>
    </item>
    <item>
      <title>Archives</title>
      <link>https://liubaoshuai1402.github.io/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/archives/</guid>
      <description></description>
    </item>
    <item>
      <title>枭枭不爱咕咕叫</title>
      <link>https://liubaoshuai1402.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/about/</guid>
      <description>&lt;p&gt;保藏秘密、分享知识，人间美德。谦谦君子，温润如是。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
