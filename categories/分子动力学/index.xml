<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>分子动力学 on BOGHTW</title>
    <link>https://liubaoshuai1402.github.io/categories/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/</link>
    <description>Recent content in 分子动力学 on BOGHTW</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 17 Jun 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://liubaoshuai1402.github.io/categories/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LAMMPS-dump</title>
      <link>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/dump/</link>
      <pubDate>Tue, 17 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/dump/</guid>
      <description>&lt;h1 id=&#34;有用的dump&#34;&gt;有用的dump&lt;/h1&gt;&#xA;&lt;h3 id=&#34;1-如何由lammps的轨迹转化为poscar&#34;&gt;1. 如何由lammps的轨迹转化为POSCAR&lt;/h3&gt;&#xA;&lt;p&gt;构建机器学习势时，通常需要主动学习。主动学习就需要将用MLIAP跑出来的结果返回到DFT中进行计算。&lt;/p&gt;&#xA;&lt;p&gt;具体来讲，要将分子动力学轨迹转化为第一性原理的输入格式。（如从lammps到vasp）&lt;/p&gt;&#xA;&lt;p&gt;lammps并不直接支持输出POSCAR格式，比较容易想到的思路是让lammps输出xyz文件，再有xyz文件转化为POSCAR。&lt;/p&gt;&#xA;&lt;p&gt;不过麻烦的一点是，lammps输出xyz文件并不带有晶格大小的信息，无法转化为POSCAR。&lt;/p&gt;&#xA;&lt;p&gt;这里，我目前的方案是，先用custom style的dump输出文件，如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;dump          1 all custom 1 dump20nvt id element x y z&#xD;&#xA;dump_modify   1 sort id element O Zr Y H&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;为了避免输出lammps中的type，而不是元素符号，这里修饰一下dump（即 &lt;code&gt;element O Zr Y H&lt;/code&gt;），这里O、Zr、Y、H分别对应 type 1、2、3、4&lt;/p&gt;&#xA;&lt;p&gt;sort id 必不可少，保证原子对应。&lt;/p&gt;&#xA;&lt;p&gt;这样得到的dump文件格式，如下：&lt;/p&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/dump%E7%9A%84custom%E9%A3%8E%E6%A0%BC.png&#34; style=&#34;zoom:70%;&#34; /&gt;&#xD;&#xA;&lt;p&gt;可以看到，同时包含了元素符号、晶格和原子坐标信息。其实这个自定义风格，&lt;code&gt;custom&lt;/code&gt;，就是稍加修改的&lt;code&gt;atom&lt;/code&gt;风格。&lt;/p&gt;&#xA;&lt;p&gt;剩下的问题就是，如何将lammps的dump文件转化为xyz文件，再由xyz文件转化为POSCAR。&lt;/p&gt;&#xA;&lt;p&gt;OVITO模块读取dump文件比较好用，个人觉得比ase的强，所以这里采用ovito模块，如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ovito.io import import_file,export_file&#xD;&#xA;&#xD;&#xA;pipeline = import_file(&#39;dump&#39;)&#xD;&#xA;&#xD;&#xA;for frame,data in enumerate(pipeline.frames):&#xD;&#xA;    if frame &amp;lt; 10:&#xD;&#xA;        export_file(data,&amp;quot;xyz{}&amp;quot;.format(frame),format=&amp;quot;xyz&amp;quot;,columns =[&amp;quot;Particle Identifier&amp;quot;, &amp;quot;Particle Type&amp;quot;, &amp;quot;Position.X&amp;quot;, &amp;quot;Position.Y&amp;quot;, &amp;quot;Position.Z&amp;quot;])&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这里简单测试一下，只输出了前10个结构。结果很成功。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LAMMPS中的常见命令</title>
      <link>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/lammps%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 17 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/lammps%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</guid>
      <description>&lt;h1 id=&#34;lammps中的常见命令&#34;&gt;LAMMPS中的常见命令&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;虽然说是常见，但也未必常见吧，可能只是我遇到的不懂的、或者觉得有趣的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1labelmap&#34;&gt;1.&lt;code&gt;labelmap&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;lablemap atom 1 H 2 O&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;这个命令用于给atom type指定一个映射关系。在用&lt;code&gt;write_data&lt;/code&gt;写当前帧的data文件时，文件会含有额外的信息，如下：&lt;/p&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/labelmap.png&#34; style=&#34;zoom:60%;&#34; /&gt;&#xD;&#xA;&lt;p&gt;但只限于data文件，无法影响dump的轨迹文件，所以想要写带有元素符号的轨迹，还是用dump的custom风格比较好。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-variable&#34;&gt;2. &lt;code&gt;variable&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;想要精通LAMMPS中的&lt;code&gt;variable&lt;/code&gt;总是要费一番功夫的，今日有幸认真研究一番（本身又涉及很多别的命令，真似高中时看牛津字典，遇到一个个新单词，好爽快）。&lt;/p&gt;&#xA;&lt;p&gt;不同风格的&lt;code&gt;variable&lt;/code&gt;的&lt;mark&gt;定义&lt;/mark&gt;和&lt;mark&gt;使用&lt;/mark&gt;，会有一些差异。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;variable name style args ...&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这是官方给出的&lt;code&gt;variable&lt;/code&gt;语法，简明扼要，&lt;code&gt;variable&lt;/code&gt;由名字、风格、参数组成。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;equal&lt;/code&gt;风格&lt;/p&gt;&#xA;&lt;p&gt;它后接一个公式，可以包含：数字、常数、数学算符、内置函数、原子值（atom values）、原子矢量（atom vectors）以及compute/fix/variable的引用。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;  atom value = id[i], mass[i], type[i], mol[i], x[i], y[i], z[i], vx[i], vy[i], vz[i], fx[i], fy[i], fz[i], q[i]&#xD;&#xA;  atom vector = id, mass, type, mol, radius, q, x, y, z, vx, vy, vz, fx, fy, f&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这里，原子值是某个原子的信息，而原子矢量则是包含全体原子的信息。&lt;/p&gt;&#xA;&lt;p&gt;值得注意的是，如果涉及到原子值，在&lt;code&gt;atom_style&lt;/code&gt;之后，还要打开&lt;code&gt;atom_modify map yes&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LAMMPS剪切模拟</title>
      <link>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/lammps%E5%89%AA%E5%88%87%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Sat, 14 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/lammps%E5%89%AA%E5%88%87%E6%A8%A1%E6%8B%9F/</guid>
      <description>&lt;h1 id=&#34;lammps用于剪切模拟的in文件&#34;&gt;LAMMPS用于剪切模拟的in文件&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 3d metal shear simulation&#xD;&#xA;&#xD;&#xA;units&#x9;&#x9;metal&#xD;&#xA;boundary&#x9;s s p&#xD;&#xA;&#xD;&#xA;atom_style&#x9;atomic&#xD;&#xA;lattice&#x9;&#x9;fcc 3.52&#xD;&#xA;region&#x9;&#x9;box block 0 16.0 0 10.0 0 2.828427&#xD;&#xA;create_box&#x9;3 box&#xD;&#xA;&#xD;&#xA;lattice&#x9;&#x9;fcc 3.52 orient&#x9;x 1 0 0 orient y 0 1 1 orient z 0 -1 1 &amp;amp;&#xD;&#xA;&#x9;&#x9;origin 0.5 0 0 &#xD;&#xA;create_atoms&#x9;1 box&#xD;&#xA;&#xD;&#xA;pair_style&#x9;eam&#xD;&#xA;pair_coeff&#x9;* * Ni_u3.eam&#xD;&#xA;&#xD;&#xA;neighbor&#x9;0.3 bin&#xD;&#xA;neigh_modify&#x9;delay 5&#xD;&#xA;&#xD;&#xA;region&#x9;&#x9;lower block INF INF INF 0.9 INF INF&#xD;&#xA;region&#x9;&#x9;upper block INF INF 6.1 INF INF INF&#xD;&#xA;group&#x9;&#x9;lower region lower&#xD;&#xA;group&#x9;&#x9;upper region upper&#xD;&#xA;group&#x9;&#x9;boundary union lower upper&#xD;&#xA;group&#x9;&#x9;mobile subtract all boundary&#xD;&#xA;&#xD;&#xA;set&#x9;&#x9;group lower type 2&#xD;&#xA;set&#x9;&#x9;group upper type 3&#xD;&#xA;&#xD;&#xA;# void&#xD;&#xA;&#xD;&#xA;#region&#x9;&#x9;void cylinder z 8 5 2.5 INF INF&#xD;&#xA;#delete_atoms&#x9;region void&#xD;&#xA;&#xD;&#xA;# temp controllers&#xD;&#xA;&#xD;&#xA;compute&#x9;&#x9;new3d mobile temp&#xD;&#xA;compute&#x9;&#x9;new2d mobile temp/partial 0 1 1&#xD;&#xA;&#xD;&#xA;# equilibrate&#xD;&#xA;&#xD;&#xA;velocity&#x9;mobile create 300.0 5812775 temp new3d&#xD;&#xA;fix&#x9;&#x9;1 all nve&#xD;&#xA;fix&#x9;&#x9;2 boundary setforce 0.0 0.0 0.0&#xD;&#xA;&#xD;&#xA;fix&#x9;&#x9;3 mobile temp/rescale 10 300.0 300.0 10.0 1.0&#xD;&#xA;fix_modify&#x9;3 temp new3d&#xD;&#xA;&#xD;&#xA;thermo&#x9;&#x9;25&#xD;&#xA;thermo_modify&#x9;temp new3d&#xD;&#xA;&#xD;&#xA;timestep&#x9;0.001&#xD;&#xA;run&#x9;&#x9;100&#xD;&#xA;&#xD;&#xA;# shear&#xD;&#xA;&#xD;&#xA;velocity&#x9;upper set 1.0 0 0&#xD;&#xA;velocity&#x9;mobile ramp vx 0.0 1.0 y 1.4 8.6 sum yes&#xD;&#xA;&#xD;&#xA;unfix&#x9;&#x9;3&#xD;&#xA;fix&#x9;&#x9;3 mobile temp/rescale 10 300.0 300.0 10.0 1.0&#xD;&#xA;fix_modify&#x9;3 temp new2d&#xD;&#xA;&#xD;&#xA;#dump&#x9;&#x9;1 all atom 100 dump.shear&#xD;&#xA;&#xD;&#xA;#dump&#x9;&#x9;2 all image 100 image.*.jpg type type &amp;amp;&#xD;&#xA;#&#x9;&#x9;axes yes 0.8 0.02 view 0 0 zoom 1.5 up 0 1 0 adiam 2.0&#xD;&#xA;#dump_modify&#x9;2 pad 4&#xD;&#xA;&#xD;&#xA;#dump&#x9;&#x9;3 all movie 100 movie.mpg type type &amp;amp;&#xD;&#xA;#&#x9;&#x9;axes yes 0.8 0.02 view 0 0 zoom 1.5 up 0 1 0 adiam 2.0&#xD;&#xA;#dump_modify&#x9;3 pad 4&#xD;&#xA;&#xD;&#xA;thermo&#x9;&#x9;100&#xD;&#xA;thermo_modify&#x9;temp new2d&#xD;&#xA;&#xD;&#xA;reset_timestep&#x9;0&#xD;&#xA;run&#x9;&#x9;3000&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;compute--id--group-id--temp&#34;&gt;&lt;code&gt;compute  ID  group-ID  temp&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;计算某个原子群的温度&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用rNEMD方法计算热导率的lammps输入文件</title>
      <link>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/thermal_conductivity_rnemd/</link>
      <pubDate>Fri, 16 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/thermal_conductivity_rnemd/</guid>
      <description>&lt;h1 id=&#34;使用rnemd方法计算热导率的lammps输入文件&#34;&gt;使用rNEMD方法计算热导率的LAMMPS输入文件&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&#xD;&#xA;&lt;a href=&#34;https://doi.org/10.1063/1.473271&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;rNEMD方法&lt;/a&gt;&#xD;&#xA;，又叫MP方法，计算材料热导率。&lt;/p&gt;&#xA;&lt;p&gt;LAMMPS官方提供了计算脚本，但是使用的单位却是&lt;code&gt;lj&lt;/code&gt;单位制，非常不实用，这里是我自己写的&lt;code&gt;metal&lt;/code&gt;单位制下的脚本。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;in-file&#34;&gt;in file&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# sample LAMMPS input script for thermal conductivity of liquid LJ&#xD;&#xA;# Muller-Plathe method via fix thermal_conductivity&#xD;&#xA;&#xD;&#xA;# settings      temperature, kB and timestep&#xD;&#xA;&#xD;&#xA;variable        t equal 1500&#xD;&#xA;variable        k equal 8.6173e-5 &#xD;&#xA;variable        dt equal 0.0005&#xD;&#xA;&#xD;&#xA;# convert from LAMMPS metal units to SI&#xD;&#xA;variable        eV2J equal 1.6022e-19          #energy convert&#xD;&#xA;variable        A2m equal 1.0e-10           #distance convert&#xD;&#xA;variable        ps2s equal 1.0e-12          #time convert  &#xD;&#xA;variable        convert equal ${eV2J}/${ps2s}/${A2m}          &#xD;&#xA;&#xD;&#xA;# setup problem&#xD;&#xA;&#xD;&#xA;units           metal&#xD;&#xA;atom_style      atomic&#xD;&#xA;atom_modify     map yes&#xD;&#xA;newton          on&#xD;&#xA;read_data       ./333&#xD;&#xA;pair_style      mace no_domain_decomposition&#xD;&#xA;pair_coeff * *  /home-ssd/Users/nsgm_lbs/train/MACE_model/MACE_model_run-123_stagetwo.model-lammps.pt O Zr Y H&#xD;&#xA;neighbor        1.0 bin&#xD;&#xA;neigh_modify    every 500 delay 0 check no&#xD;&#xA;minimize        1e-5 1e-7 1000 1000&#xD;&#xA;timestep        ${dt}&#xD;&#xA;velocity        all create $t 87287&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 1st equilibration run&#xD;&#xA;reset_timestep  0&#xD;&#xA;fix             1 all npt temp $t $t 0.05 iso 0 0 0.5&#xD;&#xA;thermo_style    custom step temp pe etotal enthalpy lx ly lz vol press&#xD;&#xA;thermo          100&#xD;&#xA;run             5000&#xD;&#xA;unfix           1&#xD;&#xA;velocity        all scale $t&#xD;&#xA;fix             1 all nvt temp $t $t 0.05&#xD;&#xA;run             5000&#xD;&#xA;unfix           1&#xD;&#xA;&#xD;&#xA;# 2nd equilibration run&#xD;&#xA;compute         ke all ke/atom&#xD;&#xA;variable        temp atom c_ke/1.5/${k}&#xD;&#xA;&#xD;&#xA;fix             1 all nve&#xD;&#xA;&#xD;&#xA;compute         layers all chunk/atom bin/1d z lower 0.05 units reduced&#xD;&#xA;fix             2 all ave/chunk 10 100 1000 layers v_temp file profile.mp&#xD;&#xA;fix             3 all thermal/conductivity 100 z 20&#xD;&#xA;&#xD;&#xA;variable        tdiff equal f_2[11][3]-f_2[1][3]&#xD;&#xA;thermo_style    custom step temp epair etotal f_3 v_tdiff&#xD;&#xA;thermo_modify   colname f_3 E_delta colname v_tdiff dTemp_step&#xD;&#xA;&#xD;&#xA;thermo          1000&#xD;&#xA;run             20000&#xD;&#xA;&#xD;&#xA;# thermal conductivity calculation&#xD;&#xA;# reset fix thermal/conductivity to zero energy accumulation&#xD;&#xA;fix             3 all thermal/conductivity 100 z 20&#xD;&#xA;variable        start_time equal time&#xD;&#xA;variable        kappa equal (f_3/(time-${start_time})/(lx*ly)/2.0)*(lz/2.0)/f_ave&#xD;&#xA;fix             ave all ave/time 1 1 1000 v_tdiff ave running&#xD;&#xA;thermo_style    custom step temp epair etotal f_3 v_tdiff f_ave&#xD;&#xA;thermo_modify   colname f_3 E_delta colname v_tdiff dTemp_step colname f_ave dTemp&#xD;&#xA;run             20000&#xD;&#xA;print           &amp;quot;Running average thermal conductivity units metal: $(v_kappa)&amp;quot;&#xD;&#xA;variable        tc  equal ${kappa}*${convert}&#xD;&#xA;print           &amp;quot;Running average thermal conductivity units SI: $(v_tc:%.2f)&amp;quot;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>均方位移（MSD）-OVITO</title>
      <link>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/msd_ovito/</link>
      <pubDate>Tue, 13 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/msd_ovito/</guid>
      <description>&lt;h1 id=&#34;均方位移msd计算-by-ovito&#34;&gt;均方位移（MSD）计算 by OVITO&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&#xD;&#xA;&lt;a href=&#34;https://docs.ovito.org/python/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;OVITO Python Reference — OVITO Python Reference 3.12.3 documentation&lt;/a&gt;&#xD;&#xA; 是一个开源且功能强大的分子动力学后处理软件包。&lt;/p&gt;&#xA;&lt;p&gt;本文将介绍如何利用 OVITO python module 计算某类元素原子在一段轨迹内的均方位移。&lt;/p&gt;&#xA;&lt;p&gt;适用于无机非晶体，其他体系慎用。&lt;/p&gt;&#xA;&lt;p&gt;软件：OVITO、matplotlib、numpy&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ovito版&#34;&gt;OVITO版&lt;/h2&gt;&#xA;&lt;h3 id=&#34;代码展示&#34;&gt;代码展示&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ovito.io import import_file, export_file&#xD;&#xA;from ovito.modifiers import CalculateDisplacementsModifier&#xD;&#xA;from ovito.modifiers import SelectTypeModifier,InvertSelectionModifier,DeleteSelectedModifier,ExpressionSelectionModifier&#xD;&#xA;import numpy as np&#xD;&#xA;import matplotlib.pyplot as plt&#xD;&#xA;&#xD;&#xA;#万物起源 import_file ，导入一段要计算的轨迹&#xD;&#xA;pipeline = import_file(&amp;quot;1.dump&amp;quot;)&#xD;&#xA;&#xD;&#xA;#添加 SelectTypeModifier 修饰器&#xD;&#xA;#设置参数 property = &#39;Particle Type&#39; 指定选择的类型（这里我们指定的是原子类型）&#xD;&#xA;#设置参数 types = {4} 指定具体的原子类型，这里是这个轨迹中的 4 原子（这个值要根据自己的体系修改），这里用数字代表原子是因为我使用的lammps的输出风格没有记录原子的元素符号，如果你的轨迹里记录的是 元素符号 信息，比如说 VASP 输出的 XDATCAR，则需要用类似于 types = {&amp;quot;H&amp;quot;} 的写法&#xD;&#xA;pipeline.modifiers.append(SelectTypeModifier(property = &#39;Particle Type&#39;, types = {4}))&#xD;&#xA;&#xD;&#xA;#添加 InvertSelectionModifier 修饰器，进行原子反选，为剔除不需要计算的原子做准备&#xD;&#xA;pipeline.modifiers.append(InvertSelectionModifier())    &#xD;&#xA;&#xD;&#xA;#添加 DeleteSelectedModifier 修饰器，删除上一行代码反选的原子，留下需要计算的原子&#xD;&#xA;pipeline.modifiers.append(DeleteSelectedModifier(operate_on= {&#39;particles&#39;}))                    &#xD;&#xA;&#xD;&#xA;#添加 CalculateDisplacementsModifier 修饰器，指定计算 MSD 的参考结构，这里 reference_frame = 0 代表初始结构是参考结构&#xD;&#xA;reference_frame = 0&#xD;&#xA;pipeline.modifiers.append(CalculateDisplacementsModifier(reference_frame=0))    #a subclass of ovito.pipeline.ReferenceConfigurationModifier&#xD;&#xA;&#xD;&#xA;#自定义一个修饰器函数，用于将 per-particle displacement 转化为相应元素的均方位移&#xD;&#xA;#本文的 OVITO小知识 将简单介绍自定义修饰器是如何工作的&#xD;&#xA;def calculate_msd(frame, data):&#xD;&#xA;    &#xD;&#xA;&#x9;#用一个变量 displacement_magnitudes 记录 data.particles[&#39;Displacement Magnitude&#39;]，简化代码&#xD;&#xA;&#x9;displacement_magnitudes = data.particles[&#39;Displacement Magnitude&#39;]&#xD;&#xA;&#x9;#计算 MSD （将所有原子位移的平方加和然后求平均），OVITO 的数据可以直接和 numpy 交互，nice&#xD;&#xA;&#x9;msd = np.sum(displacement_magnitudes ** 2) / len(displacement_magnitudes)           &#xD;&#xA;&#x9;#把计算的 MSD 传递给 data (DataCollection类)&#xD;&#xA;&#x9;data.attributes[&amp;quot;MSD&amp;quot;] = msd &#xD;&#xA;    &#xD;&#xA;#添加自定义 calculate_msd 修饰器&#xD;&#xA;pipeline.modifiers.append(calculate_msd)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#计算 Pipeline, 得到time vs MSD的数据&#xD;&#xA;table = []     #用于存放数据，time vs MSD&#xD;&#xA;&#xD;&#xA;for frame,data in enumerate(pipeline.frames):&#xD;&#xA;&#x9;if frame &amp;gt;= reference_frame:&#xD;&#xA;&#x9;&#x9;#这里的 *10 一定要根据自己的计算调整，我的轨迹在lammps计算设置：时间步是0.5fs，每20步输出一帧，所以轨迹中每帧其实经历了10fs，所以乘以10&#xD;&#xA;&#x9;&#x9;#我们 time vs MSD 的x横坐标单位是fs，也可以是别的，自己调整&#xD;&#xA;&#x9;&#x9;time = (frame-reference_frame)*10                 &#xD;&#xA;&#x9;&#x9;table.append([time,data.attributes[&#39;MSD&#39;]])&#xD;&#xA;&#xD;&#xA;#.csv文件还是比较高级的，比纯txt好些，delimiter 指定间隔符为 &amp;quot;,&amp;quot; ,这样方便直接excel打开&#xD;&#xA;np.savetxt(&amp;quot;msd_data.csv&amp;quot;,table,delimiter=&amp;quot;,&amp;quot;)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;ovito小知识&#34;&gt;OVITO小知识&lt;/h2&gt;&#xA;&lt;p&gt;受限于Python基础和时间精力的限制，以下内容皆为我个人的有限理解，未能严格考究，仅供参考。&lt;/p&gt;</description>
    </item>
    <item>
      <title>径向分布函数（RDF）-OVITO</title>
      <link>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/rdf_ovito/</link>
      <pubDate>Mon, 12 May 2025 00:00:00 +0000</pubDate>
      <guid>https://liubaoshuai1402.github.io/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/rdf_ovito/</guid>
      <description>&lt;h1 id=&#34;径向分布函数rdf计算-by-ovito&#34;&gt;径向分布函数（RDF）计算 by OVITO&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&#xD;&#xA;&lt;a href=&#34;https://docs.ovito.org/python/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;OVITO Python Reference — OVITO Python Reference 3.12.3 documentation&lt;/a&gt;&#xD;&#xA; 是一个开源且功能强大的分子动力学后处理软件包。&lt;/p&gt;&#xA;&lt;p&gt;本文将介绍如何利用 OVITO python module 计算单个结构以及一段轨迹（多个结构）内的径向分布函数。&lt;/p&gt;&#xA;&lt;p&gt;适用于无机非晶体，其他体系慎用。&lt;/p&gt;&#xA;&lt;p&gt;软件：OVITO、matplotlib、numpy&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文仅供参考，欢迎指出错误或分享补充。无能力提供任何指导，&lt;strong&gt;求教者切勿留言&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-partial-rdfs-of-a-single-crystal-structure&#34;&gt;The partial RDFs of a single crystal structure&lt;/h2&gt;&#xA;&lt;h3 id=&#34;代码展示&#34;&gt;代码展示&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#这段代码用于计算 RDF by OVITO&#xA;from ovito.io import import_file&#xA;from ovito.modifiers import CoordinationAnalysisModifier&#xA;import numpy as np&#xA;&#xA;#导入一个氧化锆（ZrO2）的cif文件，所有OVITO支持的输入文件格式都可以（确保这个.py文件的路径下有这样一个cif文件，也可以稍微修改指定结构路径）&#xA;pipeline = import_file(&amp;quot;ZrO.cif&amp;quot;)&#xA;&#xA;#施加一个名叫 CoordinationAnalysisModifier 的修饰器，cutoff用于控制截断半径，number_of_bins用于控制网格细分度（大小100-1000内都可以试试）&#xA;pipeline.modifiers.append(CoordinationAnalysisModifier(cutoff = 5.0, number_of_bins = 500,partial=True))&#xA;&#xA;#进行计算&#xA;rdf_table = pipeline.compute().tables[&#39;coordination-rdf&#39;]&#xA;&#xA;#得到用于画图的横纵坐标，默认第一列是x轴数据，其余列是y轴数据&#xA;total_rdf = rdf_table.xy()&#xA;&#xA;#记录total_rdf中y轴数据对应是什么类型的pair-wise&#xA;#这个例子中，输出为：&#xA;#g(r) for pair-wise type combination O-O:&#xA;#g(r) for pair-wise type combination O-Zr:&#xA;#g(r) for pair-wise type combination Zr-Zr:&#xA;#说明total_rdf是一个四列的数据，第一列是x轴坐标（其实是bin），第二列就是不同pair-wise的RDF数据，依次为 O-O,O-Zr,Zr-Zr&#xA;rdf_names = rdf_table.y.component_names&#xA;for component, name in enumerate(rdf_names):&#xA;    print(&amp;quot;g(r) for pair-wise type combination %s:&amp;quot; % name)&#xA;    &#xA;#将total_rdf保存为txt文件，用于后续画图&#xA;np.savetxt(&amp;quot;total_rdf.txt&amp;quot;, total_rdf)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#这段代码用于绘图&#xA;import numpy as np&#xA;import matplotlib.pyplot as plt&#xA;&#xA;rdf_table = np.loadtxt(&#39;total_rdf.txt&#39;)&#xA;&#xA;#g(r) for pair-wise type combination O-O:&#xA;#g(r) for pair-wise type combination O-Zr:&#xA;#g(r) for pair-wise type combination Zr-Zr:&#xA;&#xA;#这里取的是 total_rdf.txt 中的第一列（对应[:,0]）和第三列（对应[:,2]），所以绘制的是 Zr-O pair-wise的partial RDF&#xA;plt.plot(rdf_table[:,0], rdf_table[:,2])&#xA;&#xA;#matplotlib的常规设置，问问万能的小迪老师吧&#xA;title_font = {&#39;fontsize&#39;: 24, &#39;fontfamily&#39;: &#39;Times New Roman&#39;}&#xA;xlabel_font = {&#39;fontsize&#39;: 22, &#39;fontfamily&#39;: &#39;Times New Roman&#39;}&#xA;ylabel_font = {&#39;fontsize&#39;: 22, &#39;fontfamily&#39;: &#39;Times New Roman&#39;}&#xA;&#xA;plt.title(&amp;quot;RDF Zr-O&amp;quot;, fontdict=title_font,pad=8)&#xA;plt.xlabel(xlabel=&#39;distance r&#39;,fontdict=xlabel_font,loc=&#39;center&#39;,labelpad=8)&#xA;plt.ylabel(ylabel=&#39;g(r)&#39;,fontdict=ylabel_font,loc=&#39;center&#39;,labelpad=8)&#xA;plt.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16, direction=&#39;in&#39;)&#xA;&#xA;ax = plt.subplot()&#xA;&#xA;#因为只有一个静态结构，pair-wise的某些峰很高，所以这里的y轴坐标上限设置大一些，为200，可灵活改变&#xA;#x轴设置为6，稍大于截断半径cutoff即可，因为本身也只在截断半径以内统计&#xA;ax.set_ylim(0,200)&#xA;plt.xlim(0,6)&#xA;&#xA;fig = plt.gcf()&#xA;&#xA;fig.set_size_inches(1200/100, 800/100)&#xA;plt.savefig(&#39;output.png&#39;, dpi=100)&#xA;&#xA;plt.show()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;结果展示&#34;&gt;结果展示&lt;/h3&gt;&#xA;&lt;img src=&#34;https://xiaoxiaobuaigugujiao.oss-cn-beijing.aliyuncs.com/img/output.png&#34;/&gt;&#xA;&lt;h2 id=&#34;the-partial-rdfs-of-trajectories&#34;&gt;The partial RDFs of trajectories&lt;/h2&gt;&#xA;&lt;h3 id=&#34;代码展示-1&#34;&gt;代码展示&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#这段代码用于计算一定时间内（一段轨迹）的平均 RDFs&#xA;from ovito.io import import_file&#xA;from ovito.modifiers import CoordinationAnalysisModifier,TimeAveragingModifier&#xA;import numpy as np&#xA;&#xA;#读入轨迹文件，这里是利用 VASP 进行 AIMD 后得到的 XDATCAR 文件&#xA;pipeline = import_file(&amp;quot;XDATCAR&amp;quot;)&#xA;&#xA;#打印轨迹中的结构数&#xA;print(&amp;quot;Number of MD frames:&amp;quot;, pipeline.num_frames)&#xA;&#xA;#添加修饰器，与单个晶体结构相比，多了 TimeAveragingModifier 修饰器&#xA;pipeline.modifiers.append(CoordinationAnalysisModifier(cutoff = 5.0, number_of_bins = 500,partial=True))&#xA;pipeline.modifiers.append(TimeAveragingModifier(operate_on=&#39;table:coordination-rdf&#39;))&#xA;&#xA;#计算 RDFs 数据&#xA;total_rdf = pipeline.compute().tables[&#39;coordination-rdf[average]&#39;].xy()&#xA;&#xA;#记录pair-wise类型&#xA;rdf_names = pipeline.compute().tables[&#39;coordination-rdf[average]&#39;].y.component_names&#xA;for name in rdf_names:&#xA;    print(&amp;quot;g(r) for pair-wise type combination %s:&amp;quot; % name)&#xA;&#xA;#输出数据，用于后续绘图，不再重复&#xA;np.savetxt(&#39;rdf.txt&#39;, total_rdf, delimiter=&#39;\t&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;ovito小知识&#34;&gt;OVITO小知识&lt;/h2&gt;&#xA;&lt;p&gt;受限于Python基础和时间精力的限制，以下内容皆为我个人的有限理解，未能严格考究，仅供参考。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
